#!/bin/bash

export LANG=en_US.UTF-8

RED="\033[31m"
GREEN="\033[32m"
YELLOW="\033[33m"
BLUE="\033[34m"
PURPLE="\033[35m"
CYAN="\033[36m"
PLAIN="\033[0m"

red() { echo -e "${RED}$1${PLAIN}"; }
green() { echo -e "${GREEN}$1${PLAIN}"; }
yellow() { echo -e "${YELLOW}$1${PLAIN}"; }
blue() { echo -e "${BLUE}$1${PLAIN}"; }
purple() { echo -e "${PURPLE}$1${PLAIN}"; }
cyan() { echo -e "${CYAN}$1${PLAIN}"; }

XRAY_DIR="/usr/local/etc/xray"
CLIENT_DIR="/root/vless-clients"
LOG_DIR="/var/log/xray"
BACKUP_DIR="/root/vless-backups"

REALITY_TARGETS=(
    "www.apple.com:443"
    "www.microsoft.com:443"
    "www.lovelive-anime.jp:443"
    "www.cisco.com:443"
)

[[ $EUID -ne 0 ]] && red "[!] 请使用 root 用户运行本脚本！" && exit 1

detect_system() {
    if [[ -f /etc/os-release ]]; then
        source /etc/os-release
        SYSTEM="$ID"
        VERSION="$VERSION_ID"
    else
        red "[!] 无法检测系统类型"
        exit 1
    fi

    case $SYSTEM in
        "ubuntu"|"debian")
            PKG_MANAGER="apt"
            PKG_INSTALL="apt install -y"
            PKG_UPDATE="apt update -y"
            ;;
        "centos"|"rhel"|"fedora"|"rocky"|"almalinux")
            PKG_MANAGER="yum"
            PKG_INSTALL="yum install -y"
            PKG_UPDATE="yum update -y"
            ;;
        *)
            red "[!] 不支持的系统: $SYSTEM"
            exit 1
            ;;
    esac

    yellow "[*] 检测到系统: $SYSTEM $VERSION"
}

wait_for_package_manager() {
    yellow "[*] 检查包管理器..."
    
    local max_attempts=60
    local attempt=0
    
    while [[ $attempt -lt $max_attempts ]]; do
        if ! fuser /var/lib/dpkg/lock-frontend /var/lib/dpkg/lock /var/cache/apt/archives/lock >/dev/null 2>&1; then
            break
        fi
        
        if [[ $attempt -eq 0 ]]; then
            yellow "[*] 等待包管理器..."
        fi
        
        echo -n "."
        sleep 5
        ((attempt++))
    done
    
    echo ""
    
    if [[ $attempt -ge $max_attempts ]]; then
        killall apt apt-get dpkg 2>/dev/null
        sleep 2
        rm -f /var/lib/dpkg/lock-frontend /var/lib/dpkg/lock /var/cache/apt/archives/lock
        dpkg --configure -a
    fi
}

install_dependencies() {
    yellow "[*] 安装依赖和安全工具..."
    
    wait_for_package_manager
    $PKG_UPDATE
    
    case $SYSTEM in
        "ubuntu"|"debian")
            $PKG_INSTALL curl wget unzip tar qrencode ufw jq bc \
                         net-tools dnsutils openssl socat cron
            
            $PKG_INSTALL fail2ban 2>/dev/null || yellow "[!] fail2ban 安装失败，跳过"
            $PKG_INSTALL chrony 2>/dev/null || $PKG_INSTALL ntp 2>/dev/null
            
            systemctl enable --now chronyd 2>/dev/null || systemctl enable --now ntpd 2>/dev/null
            ;;
        "centos"|"rhel"|"fedora"|"rocky"|"almalinux")
            $PKG_INSTALL curl wget unzip tar qrencode firewalld jq bc \
                         net-tools bind-utils openssl socat chrony
            
            $PKG_INSTALL fail2ban 2>/dev/null || yellow "[!] fail2ban 安装失败，跳过"
            
            systemctl enable --now chronyd 2>/dev/null
            ;;
    esac
    
    if command -v fail2ban-client &> /dev/null; then
        setup_fail2ban
    fi
}

setup_fail2ban() {
    yellow "[*] 配置 fail2ban..."
    
    systemctl enable --now fail2ban 2>/dev/null
    
    mkdir -p /etc/fail2ban/filter.d
    cat > /etc/fail2ban/filter.d/xray.conf <<'EOF'
[Definition]
failregex = .*rejected.* from <HOST>:.*
            .*invalid.* from <HOST>:.*
            .*failed.* from <HOST>:.*
ignoreregex =
EOF

    mkdir -p /etc/fail2ban/jail.d
    cat > /etc/fail2ban/jail.d/xray.conf <<EOF
[xray]
enabled = true
port = 80,443,8443
filter = xray
logpath = $LOG_DIR/error.log
maxretry = 3
bantime = 3600
findtime = 600
EOF
    
    systemctl restart fail2ban 2>/dev/null
    green "[*] fail2ban 配置完成"
}

get_server_ip() {
    yellow "[*] 获取服务器 IP..."
    
    IP_SOURCES=(
        "https://api.ipify.org"
        "https://icanhazip.com"
        "https://ipv4.icanhazip.com"
        "https://checkip.amazonaws.com"
    )
    
    for source in "${IP_SOURCES[@]}"; do
        SERVER_IP=$(curl -s --connect-timeout 5 --max-time 10 "$source" 2>/dev/null | grep -E '^[0-9.]+$')
        [[ -n "$SERVER_IP" ]] && break
    done
    
    if [[ -z "$SERVER_IP" ]]; then
        red "[!] 无法获取服务器 IP"
        exit 1
    fi
    
    yellow "[*] 服务器 IP: $SERVER_IP"
}

select_reality_target() {
    yellow "[*] 测试 Reality 目标速度..."
    
    declare -A target_speeds
    
    for target in "${REALITY_TARGETS[@]}"; do
        host="${target%:*}"
        port="${target#*:}"
        
        total_time=0
        success_count=0
        
        for i in {1..3}; do
            start_time=$(date +%s%N)
            if timeout 3 bash -c "echo > /dev/tcp/$host/$port" 2>/dev/null; then
                end_time=$(date +%s%N)
                time_ms=$(( (end_time - start_time) / 1000000 ))
                total_time=$((total_time + time_ms))
                ((success_count++))
            fi
        done
        
        if [[ $success_count -gt 0 ]]; then
            avg_time=$((total_time / success_count))
            target_speeds[$target]=$avg_time
            yellow "    $host: ${avg_time}ms"
        fi
    done
    
    REALITY_TARGET=""
    min_time=999999
    
    for target in "${!target_speeds[@]}"; do
        if [[ ${target_speeds[$target]} -lt $min_time ]]; then
            min_time=${target_speeds[$target]}
            REALITY_TARGET="$target"
        fi
    done
    
    if [[ -z "$REALITY_TARGET" ]]; then
        yellow "[!] 所有目标都无法访问，使用默认"
        REALITY_TARGET="${REALITY_TARGETS[0]}"
    fi
    
    REALITY_DEST="${REALITY_TARGET%:*}"
    REALITY_PORT="${REALITY_TARGET#*:}"
    
    green "[*] 选择最快目标: $REALITY_DEST (${min_time}ms)"
}

install_xray() {
    yellow "[*] 安装 Xray-core (最新版)..."
    
    LATEST_VERSION=$(curl -s "https://api.github.com/repos/XTLS/Xray-core/releases/latest" | jq -r '.tag_name' | sed 's/v//')
    
    if [[ -z "$LATEST_VERSION" ]]; then
        red "[!] 无法获取最新版本"
        exit 1
    fi
    
    yellow "[*] 最新版本: $LATEST_VERSION"
    
    ARCH=$(uname -m)
    case $ARCH in
        x86_64) ARCH="64" ;;
        aarch64) ARCH="arm64-v8a" ;;
        armv7l) ARCH="arm32-v7a" ;;
        *) red "[!] 不支持的架构: $ARCH"; exit 1 ;;
    esac
    
    DOWNLOAD_URL="https://github.com/XTLS/Xray-core/releases/download/v$LATEST_VERSION/Xray-linux-$ARCH.zip"
    
    cd /tmp || exit 1
    
    if ! wget -O xray.zip "$DOWNLOAD_URL" 2>/dev/null; then
        yellow "[*] 直连失败，尝试镜像..."
        wget -O xray.zip "https://ghproxy.com/$DOWNLOAD_URL" || {
            red "[!] 下载失败"
            exit 1
        }
    fi
    
    unzip -o xray.zip
    
    mkdir -p /usr/local/bin /usr/local/etc/xray /var/log/xray
    mv xray /usr/local/bin/
    chmod +x /usr/local/bin/xray
    
    if /usr/local/bin/xray version | grep -q "Xray"; then
        green "[*] Xray 安装成功: $(/usr/local/bin/xray version | head -1)"
    else
        red "[!] Xray 安装失败"
        exit 1
    fi
    
    rm -f /tmp/xray.zip /tmp/xray
}

generate_keys() {
    yellow "[*] 生成 Reality 密钥..."

    # ==== 目录准备 ====
    mkdir -p "$XRAY_DIR" "$CLIENT_DIR" "$LOG_DIR" "$BACKUP_DIR"

    USER_UUID=$(cat /proc/sys/kernel/random/uuid)

    # ==== 自动检测 xray 路径 ====
    XRAY_BIN=""
    for p in /usr/local/bin/xray /usr/bin/xray /root/xray /opt/xray/xray; do
        if [[ -x "$p" ]]; then
            XRAY_BIN="$p"
            break
        fi
    done

    if [[ -z "$XRAY_BIN" ]]; then
        red "[!] 未检测到 xray 可执行文件，请确认已正确安装。"
        red "    可尝试执行命令:  which xray"
        exit 1
    fi

    yellow "[*] 使用 Xray 可执行文件: $XRAY_BIN"
    yellow "[*] 正在生成 Reality 密钥对..."

    local temp_key_file="/tmp/xray_keys_$$.txt"

    if ! "$XRAY_BIN" x25519 > "$temp_key_file" 2>&1; then
        red "[!] Xray 执行失败，可能路径错误或 xray 未安装。"
        cat "$temp_key_file"
        rm -f "$temp_key_file"
        exit 1
    fi

    yellow "[*] Xray 密钥生成输出："
    cat "$temp_key_file"

    # ==== 提取密钥 ====
    # 兼容多种输出格式，例如：
    # Private key: xxx
    # PrivateKey: xxx
    # private: xxx
    # 等等

    PRIVATE_KEY=$(awk '/[Pp]rivate/{print $NF}' "$temp_key_file" | tr -d '\r\n' | head -1)
    PUBLIC_KEY=$(awk '/[Pp]ublic/{print $NF}' "$temp_key_file" | tr -d '\r\n' | head -1)

    # 如果提取失败，尝试另一种方式
    if [[ -z "$PRIVATE_KEY" || -z "$PUBLIC_KEY" ]]; then
        PRIVATE_KEY=$(grep -ioE '[A-Za-z0-9_-]{40,}' "$temp_key_file" | head -1)
        PUBLIC_KEY=$(grep -ioE '[A-Za-z0-9_-]{40,}' "$temp_key_file" | tail -1)
    fi

    rm -f "$temp_key_file"

    # ==== 验证密钥 ====
    if [[ -z "$PRIVATE_KEY" ]] || [[ ${#PRIVATE_KEY} -lt 40 ]]; then
        red "[!] Private Key 生成失败或格式错误"
        red "    Private Key: '$PRIVATE_KEY'"
        exit 1
    fi

    if [[ -z "$PUBLIC_KEY" ]] || [[ ${#PUBLIC_KEY} -lt 40 ]]; then
        red "[!] Public Key 生成失败或格式错误"
        red "    Public Key: '$PUBLIC_KEY'"
        exit 1
    fi

    green "[*] 密钥生成成功"
    yellow "    Private Key: ${PRIVATE_KEY:0:20}...${PRIVATE_KEY: -10}"
    yellow "    Public Key: ${PUBLIC_KEY:0:20}...${PUBLIC_KEY: -10}"

    # ==== 生成 Short ID ====
    SHORT_ID=$(openssl rand -hex 8)

    # ==== 自动分配端口 ====
    if ss -tlnp | grep -q ":443 "; then
        LISTEN_PORT=$(shuf -i 10000-65000 -n 1)
        while ss -tlnp | grep -q ":$LISTEN_PORT "; do
            LISTEN_PORT=$(shuf -i 10000-65000 -n 1)
        done
        yellow "[!] 443 端口被占用，自动使用端口 $LISTEN_PORT"
    else
        LISTEN_PORT=443
        green "[*] 使用最优端口: 443"
    fi

    # ==== 保存结果 ====
    cat > "$XRAY_DIR/keys.txt" <<EOF
Private Key: $PRIVATE_KEY
Public Key: $PUBLIC_KEY
UUID: $USER_UUID
Short ID: $SHORT_ID
Listen Port: $LISTEN_PORT
Reality Target: ${REALITY_DEST:-www.cloudflare.com}:${REALITY_PORT:-443}
Install Date: $(date)
EOF

    chmod 600 "$XRAY_DIR/keys.txt"

    green "[*] Reality 密钥与配置信息已保存至: $XRAY_DIR/keys.txt"
}

configure_xray_server() {
    yellow "[*] 配置 Xray 服务器（速度+安全优化）..."
    
    mkdir -p "$XRAY_DIR" "$LOG_DIR"
    
    cat > "$XRAY_DIR/config.json" <<EOF
{
    "log": {
        "access": "$LOG_DIR/access.log",
        "error": "$LOG_DIR/error.log",
        "loglevel": "warning"
    },
    "inbounds": [
        {
            "port": $LISTEN_PORT,
            "protocol": "vless",
            "settings": {
                "clients": [
                    {
                        "id": "$USER_UUID",
                        "flow": "xtls-rprx-vision"
                    }
                ],
                "decryption": "none"
            },
            "streamSettings": {
                "network": "tcp",
                "security": "reality",
                "realitySettings": {
                    "dest": "$REALITY_DEST:$REALITY_PORT",
                    "serverNames": [
                        "$REALITY_DEST"
                    ],
                    "privateKey": "$PRIVATE_KEY",
                    "shortIds": [
                        "$SHORT_ID",
                        ""
                    ]
                },
                "tcpSettings": {
                    "acceptProxyProtocol": false,
                    "header": {
                        "type": "none"
                    }
                }
            },
            "sniffing": {
                "enabled": true,
                "destOverride": ["http", "tls", "quic"]
            }
        }
    ],
    "outbounds": [
        {
            "protocol": "freedom",
            "settings": {
                "domainStrategy": "UseIPv4"
            },
            "tag": "direct"
        },
        {
            "protocol": "blackhole",
            "settings": {},
            "tag": "blocked"
        }
    ],
    "routing": {
        "domainStrategy": "AsIs",
        "rules": [
            {
                "type": "field",
                "ip": [
                    "geoip:private"
                ],
                "outboundTag": "blocked"
            },
            {
                "type": "field",
                "domain": [
                    "geosite:category-ads-all"
                ],
                "outboundTag": "blocked"
            }
        ]
    },
    "policy": {
        "levels": {
            "0": {
                "handshake": 2,
                "connIdle": 300,
                "uplinkOnly": 1,
                "downlinkOnly": 1,
                "bufferSize": 512
            }
        },
        "system": {
            "statsInboundUplink": false,
            "statsInboundDownlink": false
        }
    }
}
EOF

    chmod 644 "$XRAY_DIR/config.json"
    
    yellow "[*] 下载 Geo 数据..."
    wget -q -O "$XRAY_DIR/geoip.dat" "https://github.com/Loyalsoldier/v2ray-rules-dat/releases/latest/download/geoip.dat" 2>/dev/null || \
    wget -q -O "$XRAY_DIR/geoip.dat" "https://cdn.jsdelivr.net/gh/Loyalsoldier/v2ray-rules-dat@release/geoip.dat"
    
    wget -q -O "$XRAY_DIR/geosite.dat" "https://github.com/Loyalsoldier/v2ray-rules-dat/releases/latest/download/geosite.dat" 2>/dev/null || \
    wget -q -O "$XRAY_DIR/geosite.dat" "https://cdn.jsdelivr.net/gh/Loyalsoldier/v2ray-rules-dat@release/geosite.dat"
    
    ln -sf "$XRAY_DIR/geoip.dat" /usr/local/bin/geoip.dat
    ln -sf "$XRAY_DIR/geosite.dat" /usr/local/bin/geosite.dat
    
    yellow "[*] 验证配置..."
    if /usr/local/bin/xray -test -config="$XRAY_DIR/config.json"; then
        green "[*] 配置验证成功"
    else
        red "[!] 配置验证失败"
        red "[!] 请检查配置文件: $XRAY_DIR/config.json"
        red "[!] 密钥信息: $XRAY_DIR/keys.txt"
        exit 1
    fi
}

create_systemd_service() {
    yellow "[*] 创建系统服务..."
    
    cat > /etc/systemd/system/xray.service <<EOF
[Unit]
Description=Xray Service (Speed + Security Optimized)
Documentation=https://github.com/xtls
After=network.target nss-lookup.target
Wants=network.target

[Service]
Type=simple
User=root
ExecStart=/usr/local/bin/xray run -config $XRAY_DIR/config.json
Restart=on-failure
RestartSec=3
LimitNOFILE=1048576
LimitNPROC=512

CPUSchedulingPolicy=other
CPUSchedulingPriority=0
IOSchedulingClass=best-effort
IOSchedulingPriority=4

NoNewPrivileges=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=/var/log/xray
PrivateTmp=true
ProtectControlGroups=true
ProtectKernelTunables=true
ProtectKernelModules=true

[Install]
WantedBy=multi-user.target
EOF

    systemctl daemon-reload
    systemctl enable xray
    
    if systemctl start xray; then
        sleep 2
        if systemctl is-active --quiet xray; then
            green "[*] Xray 服务启动成功"
        else
            red "[!] Xray 服务启动失败"
            journalctl -u xray --no-pager -n 20
            exit 1
        fi
    else
        red "[!] 无法启动 Xray"
        exit 1
    fi
}

configure_firewall() {
    yellow "[*] 配置防火墙..."
    
    if command -v ufw &> /dev/null; then
        ufw --force reset >/dev/null 2>&1
        ufw default deny incoming
        ufw default allow outgoing
        ufw allow ssh
        ufw allow $LISTEN_PORT comment 'VLESS Reality'
        ufw --force enable
    fi
    
    iptables -I INPUT -p tcp --dport $LISTEN_PORT -j ACCEPT 2>/dev/null
    iptables -I INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT 2>/dev/null
    
    iptables -N PORT_SCAN 2>/dev/null
    iptables -F PORT_SCAN 2>/dev/null
    iptables -A PORT_SCAN -p tcp --tcp-flags ALL NONE -j DROP 2>/dev/null
    iptables -A PORT_SCAN -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP 2>/dev/null
    
    if command -v iptables-save &> /dev/null; then
        iptables-save > /etc/iptables/rules.v4 2>/dev/null
    fi
}

generate_client_configs() {
    yellow "[*] 生成客户端配置..."
    
    mkdir -p "$CLIENT_DIR"
    
    cat > "$CLIENT_DIR/client.json" <<EOF
{
    "log": {
        "loglevel": "warning"
    },
    "inbounds": [
        {
            "port": 1080,
            "listen": "127.0.0.1",
            "protocol": "socks",
            "settings": {
                "udp": true
            }
        },
        {
            "port": 1081,
            "listen": "127.0.0.1",
            "protocol": "http"
        }
    ],
    "outbounds": [
        {
            "protocol": "vless",
            "settings": {
                "vnext": [
                    {
                        "address": "$SERVER_IP",
                        "port": $LISTEN_PORT,
                        "users": [
                            {
                                "id": "$USER_UUID",
                                "encryption": "none",
                                "flow": "xtls-rprx-vision"
                            }
                        ]
                    }
                ]
            },
            "streamSettings": {
                "network": "tcp",
                "security": "reality",
                "realitySettings": {
                    "serverName": "$REALITY_DEST",
                    "fingerprint": "chrome",
                    "publicKey": "$PUBLIC_KEY",
                    "shortId": "$SHORT_ID",
                    "spiderX": "/"
                },
                "tcpSettings": {
                    "header": {
                        "type": "none"
                    }
                }
            },
            "tag": "proxy"
        },
        {
            "protocol": "freedom",
            "tag": "direct"
        }
    ],
    "routing": {
        "domainStrategy": "IPIfNonMatch",
        "rules": [
            {
                "type": "field",
                "domain": ["geosite:cn"],
                "outboundTag": "direct"
            },
            {
                "type": "field",
                "ip": ["geoip:cn", "geoip:private"],
                "outboundTag": "direct"
            }
        ]
    }
}
EOF

    VLESS_LINK="vless://$USER_UUID@$SERVER_IP:$LISTEN_PORT?encryption=none&flow=xtls-rprx-vision&security=reality&sni=$REALITY_DEST&fp=chrome&pbk=$PUBLIC_KEY&sid=$SHORT_ID&type=tcp&headerType=none#VLESS-Reality-Ultimate"
    
    echo "$VLESS_LINK" > "$CLIENT_DIR/share-link.txt"
    
    cat > "$CLIENT_DIR/README.txt" <<EOF
VLESS Reality 终极完整版
========================

服务器信息:
- IP: $SERVER_IP
- 端口: $LISTEN_PORT
- UUID: $USER_UUID
- Flow: xtls-rprx-vision
- SNI: $REALITY_DEST
- 公钥: $PUBLIC_KEY
- Short ID: $SHORT_ID

分享链接:
$VLESS_LINK

管理命令:
- vless-mgr status      # 完整状态
- vless-mgr qr          # 二维码
- vless-mgr security    # 安全信息
- vless-mgr backup      # 备份配置
- vless-mgr logs        # 查看日志

安装时间: $(date)
EOF

    chmod 600 "$CLIENT_DIR"/*
}

optimize_system() {
    yellow "[*] 系统优化..."
    
    cat >> /etc/sysctl.conf <<'EOF'

# VLESS Reality 优化
net.core.rmem_max = 268435456
net.core.wmem_max = 268435456
net.core.netdev_max_backlog = 16384
net.ipv4.tcp_rmem = 8192 262144 268435456
net.ipv4.tcp_wmem = 8192 262144 268435456
net.ipv4.tcp_congestion_control = bbr
net.core.default_qdisc = fq_codel
net.ipv4.tcp_fastopen = 3
net.ipv4.tcp_slow_start_after_idle = 0
net.ipv4.ip_forward = 1
fs.file-max = 2097152
EOF

    sysctl -p >/dev/null 2>&1
    
    cat >> /etc/security/limits.conf <<'EOF'
* soft nofile 1048576
* hard nofile 1048576
root soft nofile 1048576
root hard nofile 1048576
EOF
}

create_monitoring() {
    yellow "[*] 创建监控系统..."
    
    cat > /usr/local/bin/xray-monitor <<'EOF'
#!/bin/bash

if ! systemctl is-active --quiet xray; then
    systemctl restart xray
    logger "Xray auto-restarted"
fi
EOF

    chmod +x /usr/local/bin/xray-monitor
    
    (crontab -l 2>/dev/null; echo "*/5 * * * * /usr/local/bin/xray-monitor") | crontab -
}

create_management_tools() {
    yellow "[*] 创建管理工具..."
    
    cat > /usr/local/bin/vless-mgr <<'EOF'
#!/bin/bash

XRAY_DIR="/usr/local/etc/xray"
CLIENT_DIR="/root/vless-clients"

show_status() {
    echo "=== VLESS Reality 状态 ==="
    systemctl status xray --no-pager -l
}

show_config() {
    [[ -f "$CLIENT_DIR/README.txt" ]] && cat "$CLIENT_DIR/README.txt" || echo "配置不存在"
}

show_qr() {
    [[ -f "$CLIENT_DIR/share-link.txt" ]] && qrencode -t ANSIUTF8 < "$CLIENT_DIR/share-link.txt" || echo "链接不存在"
}

show_security() {
    echo "=== 安全状态 ==="
    echo "Xray: $(systemctl is-active xray)"
    echo "Fail2ban: $(systemctl is-active fail2ban 2>/dev/null || echo '未安装')"
}

case "$1" in
    status|st) show_status ;;
    config|cfg) show_config ;;
    qr) show_qr ;;
    security|sec) show_security ;;
    restart|rs) systemctl restart xray ;;
    *)
        echo "VLESS Reality 管理工具"
        echo "用法: vless-mgr {status|config|qr|security|restart}"
        ;;
esac
EOF

    chmod +x /usr/local/bin/vless-mgr
}

main() {
    cyan "========================================"
    cyan "  VLESS Reality 终极完整版"
    cyan "========================================"
    echo ""
    
    detect_system
    install_dependencies
    get_server_ip
    select_reality_target
    install_xray
    generate_keys
    configure_xray_server
    create_systemd_service
    configure_firewall
    generate_client_configs
    optimize_system
    create_monitoring
    create_management_tools
    
    green "\n========================================"
    green "  VLESS Reality 安装成功! ✅"
    green "========================================"
    echo ""
    cyan "服务器信息:"
    echo "  IP: $SERVER_IP"
    echo "  端口: $LISTEN_PORT"
    echo "  UUID: $USER_UUID"
    echo "  Flow: xtls-rprx-vision"
    echo ""
    cyan "连接链接:"
    cat "$CLIENT_DIR/share-link.txt"
    echo ""
    cyan "管理命令:"
    echo "  vless-mgr status    # 查看状态"
    echo "  vless-mgr qr        # 显示二维码"
    echo "  vless-mgr config    # 显示配置"
    echo ""
    yellow "二维码:"
    qrencode -t ANSIUTF8 < "$CLIENT_DIR/share-link.txt"
    echo ""
    green "安装完成! 🚀"
    echo "详细信息: cat $CLIENT_DIR/README.txt"
    echo "========================================"
}

main "$@"