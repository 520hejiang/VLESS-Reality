#!/bin/bash

set -uo pipefail
export LANG=en_US.UTF-8

# 颜色定义
RED="\033[31m"
GREEN="\033[32m"
YELLOW="\033[33m"
BLUE="\033[34m"
CYAN="\033[36m"
PLAIN="\033[0m"

red() { echo -e "${RED}$*${PLAIN}"; }
green() { echo -e "${GREEN}$*${PLAIN}"; }
yellow() { echo -e "${YELLOW}$*${PLAIN}"; }
blue() { echo -e "${BLUE}$*${PLAIN}"; }
cyan() { echo -e "${CYAN}$*${PLAIN}"; }

# 配置路径
XRAY_DIR="/usr/local/etc/xray"
CLIENT_DIR="/root/vless-clients"
LOG_DIR="/var/log/xray"
LOG_FILE="${LOG_DIR}/access.log"
ERROR_LOG="${LOG_DIR}/error.log"

# Reality 目标池
REALITY_TARGETS=(
    "www.microsoft.com:443"
    "www.apple.com:443"
    "www.cloudflare.com:443"
    "www.amazon.com:443"
    "addons.mozilla.org:443"
    "www.lovelive-anime.jp:443"
)

# 全局变量
SERVER_IP=""
REALITY_DEST=""
REALITY_PORT=443
USER_UUID=""
PRIVATE_KEY=""
PUBLIC_KEY=""
SHORT_ID=""
LISTEN_PORT=443
SYSTEM=""
PKG_INSTALL=""
PKG_UPDATE=""

# 检查 root
check_root() {
    [[ $EUID -ne 0 ]] && red "错误: 需要 root 权限" && exit 1
}

# 检测系统
detect_system() {
    cyan "===================================="
    cyan "  检测系统环境"
    cyan "===================================="
    
    [[ ! -f /etc/os-release ]] && red "错误: 无法检测系统" && exit 1
    
    source /etc/os-release
    SYSTEM="$ID"
    
    case $SYSTEM in
        ubuntu|debian)
            PKG_INSTALL="apt-get install -y"
            PKG_UPDATE="apt-get update -y"
            ;;
        centos|rhel|rocky|almalinux)
            PKG_INSTALL="yum install -y"
            PKG_UPDATE="yum update -y"
            [[ "$SYSTEM" == "centos" ]] && yum install -y epel-release 2>/dev/null
            ;;
        fedora)
            PKG_INSTALL="dnf install -y"
            PKG_UPDATE="dnf update -y"
            ;;
        *)
            red "错误: 不支持的系统 $SYSTEM"
            exit 1
            ;;
    esac
    
    green "[✓] 系统: $SYSTEM $VERSION_ID"
}

# 安装依赖
install_dependencies() {
    cyan "===================================="
    cyan "  安装依赖"
    cyan "===================================="
    
    yellow "[*] 更新软件源..."
    eval "$PKG_UPDATE" >/dev/null 2>&1 || true
    
    yellow "[*] 安装工具包..."
    local packages="curl wget unzip tar jq openssl qrencode"
    
    for pkg in $packages; do
        if ! command -v $pkg &>/dev/null; then
            eval "$PKG_INSTALL $pkg" >/dev/null 2>&1 || yellow "  警告: $pkg 安装失败"
        fi
    done
    
    # 时间同步
    if [[ "$SYSTEM" == "ubuntu" || "$SYSTEM" == "debian" ]]; then
        eval "$PKG_INSTALL systemd-timesyncd" >/dev/null 2>&1 || true
        systemctl enable --now systemd-timesyncd 2>/dev/null || true
    else
        eval "$PKG_INSTALL chrony" >/dev/null 2>&1 || true
        systemctl enable --now chronyd 2>/dev/null || true
    fi
    
    green "[✓] 依赖安装完成"
}

# 获取 IP
get_server_ip() {
    cyan "===================================="
    cyan "  获取服务器 IP"
    cyan "===================================="
    
    local apis=(
        "https://api.ipify.org"
        "https://icanhazip.com"
        "https://ipinfo.io/ip"
        "http://checkip.amazonaws.com"
        "https://ifconfig.me/ip"
    )
    
    yellow "[*] 正在获取 IP..."
    
    for api in "${apis[@]}"; do
        SERVER_IP=$(curl -4 -s --connect-timeout 3 --max-time 5 "$api" 2>/dev/null | grep -Eo '^[0-9]{1,3}(\.[0-9]{1,3}){3}$' | head -1)
        if [[ -n "$SERVER_IP" ]]; then
            green "[✓] 获取成功: $SERVER_IP"
            return 0
        fi
    done
    
    # 从网卡获取
    yellow "[*] API 失败，从网卡获取..."
    if command -v ip &>/dev/null; then
        SERVER_IP=$(ip -4 addr | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | grep -v '^127\.' | head -1)
    elif command -v ifconfig &>/dev/null; then
        SERVER_IP=$(ifconfig | grep 'inet ' | grep -v '127.0.0.1' | awk '{print $2}' | cut -d: -f2 | head -1)
    fi
    
    if [[ -n "$SERVER_IP" ]]; then
        green "[✓] 从网卡获取: $SERVER_IP"
        return 0
    fi
    
    # 手动输入
    yellow "[*] 无法自动获取，请手动输入"
    read -p "请输入服务器 IP: " SERVER_IP
    
    if [[ ! "$SERVER_IP" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
        red "错误: IP 格式不正确"
        exit 1
    fi
    
    green "[✓] IP: $SERVER_IP"
}

# 选择目标
select_reality_target() {
    cyan "===================================="
    cyan "  选择 Reality 目标"
    cyan "===================================="
    
    echo ""
    for i in "${!REALITY_TARGETS[@]}"; do
        echo "  $((i+1))) ${REALITY_TARGETS[i]}"
    done
    echo ""
    
    read -p "请选择 [1-${#REALITY_TARGETS[@]}, 默认 1]: " choice
    choice=${choice:-1}
    
    local idx=$((choice - 1))
    [[ $idx -lt 0 || $idx -ge ${#REALITY_TARGETS[@]} ]] && idx=0
    
    REALITY_DEST="${REALITY_TARGETS[$idx]%%:*}"
    REALITY_PORT="${REALITY_TARGETS[$idx]##*:}"
    
    green "[✓] 目标: $REALITY_DEST:$REALITY_PORT"
}

# 安装 Xray
install_xray() {
    cyan "===================================="
    cyan "  安装 Xray-core"
    cyan "===================================="
    
    local version="1.8.10"
    
    if command -v jq &>/dev/null; then
        local api_ver=$(curl -s --max-time 10 "https://api.github.com/repos/XTLS/Xray-core/releases/latest" 2>/dev/null | jq -r '.tag_name' 2>/dev/null | sed 's/v//')
        [[ -n "$api_ver" ]] && version="$api_ver"
    fi
    
    green "[✓] 版本: $version"
    
    local arch=$(uname -m)
    local xray_arch
    
    case $arch in
        x86_64) xray_arch="64" ;;
        aarch64) xray_arch="arm64-v8a" ;;
        armv7l) xray_arch="arm32-v7a" ;;
        *) red "错误: 不支持的架构 $arch" && exit 1 ;;
    esac
    
    yellow "[*] 下载 Xray..."
    
    local url="https://github.com/XTLS/Xray-core/releases/download/v${version}/Xray-linux-${xray_arch}.zip"
    
    cd /tmp
    rm -f xray.zip
    
    if ! wget -q --show-progress -O xray.zip "$url" 2>&1; then
        yellow "[*] 主源失败，尝试镜像..."
        wget -q --show-progress -O xray.zip "https://ghproxy.com/$url" 2>&1 || {
            red "错误: 下载失败"
            return 1
        }
    fi
    
    yellow "[*] 解压安装..."
    unzip -oq xray.zip
    
    mkdir -p /usr/local/bin /usr/local/share/xray "$LOG_DIR"
    
    [[ -f ./xray ]] && mv -f xray /usr/local/bin/ && chmod +x /usr/local/bin/xray
    [[ -f ./geoip.dat ]] && mv -f geoip.dat /usr/local/share/xray/
    [[ -f ./geosite.dat ]] && mv -f geosite.dat /usr/local/share/xray/
    
    if ! /usr/local/bin/xray version &>/dev/null; then
        red "错误: Xray 安装失败"
        return 1
    fi
    
    green "[✓] Xray 安装成功"
    rm -rf /tmp/xray* /tmp/Xray*
}

# 生成密钥
generate_keys() {
    yellow "[*] 生成密钥和配置..."

    # UUID
    if command -v uuidgen &>/dev/null; then
        USER_UUID=$(uuidgen | tr 'A-Z' 'a-z')
    else
        USER_UUID=$(cat /proc/sys/kernel/random/uuid)
    fi

    # Reality 密钥对
    local key_output
    key_output=$(/usr/local/bin/xray x25519 2>/dev/null)
    PRIVATE_KEY=$(echo "$key_output" | grep -i "Private key" | awk '{print $3}')
    PUBLIC_KEY=$(echo "$key_output" | grep -i "Public key" | awk '{print $3}')

    if [[ -z "$PRIVATE_KEY" || -z "$PUBLIC_KEY" ]]; then
        red "[!] 无法生成 Reality 密钥"
        exit 1
    fi

    # 生成 Short ID (8位或16位)
    SHORT_ID=$(openssl rand -hex 8)

    # 选择端口
    if ss -tlnp 2>/dev/null | grep -q ":443 "; then
        LISTEN_PORT=$(shuf -i 10000-60000 -n 1)
        while ss -tlnp 2>/dev/null | grep -q ":$LISTEN_PORT "; do
            LISTEN_PORT=$(shuf -i 10000-60000 -n 1)
        done
        yellow "[*] 端口 443 被占用，使用端口: $LISTEN_PORT"
    else
        LISTEN_PORT=443
    fi

    # 保存密钥
    mkdir -p "$XRAY_DIR"
    cat > "$XRAY_DIR/keys.txt" <<EOF
UUID: $USER_UUID
Private Key: $PRIVATE_KEY
Public Key: $PUBLIC_KEY
Short ID: $SHORT_ID
Listen Port: $LISTEN_PORT
Reality Target: $REALITY_DEST:$REALITY_PORT
Generated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
EOF
    chmod 600 "$XRAY_DIR/keys.txt"

    green "[✓] 密钥生成完成"
    green "[✓] UUID: $USER_UUID"
    green "[✓] 端口: $LISTEN_PORT"
}

# 配置 Xray
configure_xray() {
    cyan "===================================="
    cyan "  配置 Xray"
    cyan "===================================="
    
    mkdir -p "$XRAY_DIR" "$LOG_DIR"
    
    cat > "$XRAY_DIR/config.json" <<EOF
{
    "log": {
        "access": "$LOG_FILE",
        "error": "$ERROR_LOG",
        "loglevel": "warning"
    },
    "inbounds": [
        {
            "listen": "0.0.0.0",
            "port": $LISTEN_PORT,
            "protocol": "vless",
            "settings": {
                "clients": [
                    {
                        "id": "$USER_UUID",
                        "flow": ""
                    }
                ],
                "decryption": "none"
            },
            "streamSettings": {
                "network": "tcp",
                "security": "reality",
                "realitySettings": {
                    "show": false,
                    "dest": "$REALITY_DEST:$REALITY_PORT",
                    "xver": 0,
                    "serverNames": ["$REALITY_DEST"],
                    "privateKey": "$PRIVATE_KEY",
                    "shortIds": ["$SHORT_ID"]
                }
            },
            "sniffing": {
                "enabled": true,
                "destOverride": ["http", "tls"]
            }
        }
    ],
    "outbounds": [
        {
            "protocol": "freedom",
            "tag": "direct"
        },
        {
            "protocol": "blackhole",
            "tag": "block"
        }
    ],
    "routing": {
        "domainStrategy": "IPIfNonMatch",
        "rules": [
            {
                "type": "field",
                "ip": ["geoip:private"],
                "outboundTag": "block"
            }
        ]
    }
}
EOF
    
    green "[✓] 配置文件已生成"
}

# 创建服务
create_service() {
    cyan "===================================="
    cyan "  创建系统服务"
    cyan "===================================="
    
    cat > /etc/systemd/system/xray.service <<EOF
[Unit]
Description=Xray Service
After=network.target

[Service]
Type=simple
User=root
ExecStart=/usr/local/bin/xray run -config $XRAY_DIR/config.json
Restart=on-failure
RestartSec=10
LimitNOFILE=1000000

[Install]
WantedBy=multi-user.target
EOF
    
    systemctl daemon-reload
    systemctl enable xray
    systemctl start xray
    
    sleep 2
    
    if systemctl is-active --quiet xray; then
        green "[✓] Xray 服务运行正常"
    else
        red "[!] 服务启动失败"
        journalctl -u xray --no-pager -n 20
        exit 1
    fi
}

# 配置防火墙
setup_firewall() {
    cyan "===================================="
    cyan "  配置防火墙"
    cyan "===================================="
    
    if command -v ufw &>/dev/null; then
        ufw --force enable
        ufw allow ssh
        ufw allow $LISTEN_PORT/tcp
        ufw reload
        green "[✓] UFW 已配置"
    elif command -v firewall-cmd &>/dev/null; then
        systemctl enable --now firewalld
        firewall-cmd --permanent --add-port=$LISTEN_PORT/tcp
        firewall-cmd --reload
        green "[✓] Firewalld 已配置"
    else
        yellow "[!] 未检测到防火墙"
    fi
}

# 系统优化
optimize_system() {
    cyan "===================================="
    cyan "  优化系统"
    cyan "===================================="
    
    if ! grep -q "net.core.default_qdisc" /etc/sysctl.conf 2>/dev/null; then
        cat >> /etc/sysctl.conf <<EOF

# Xray Optimization
net.core.default_qdisc=fq
net.ipv4.tcp_congestion_control=bbr
net.ipv4.tcp_fastopen=3
fs.file-max=1000000
EOF
        sysctl -p >/dev/null 2>&1
        green "[✓] BBR 已启用"
    else
        green "[✓] 系统已优化"
    fi
}

# 生成客户端配置
generate_client_config() {
    cyan "===================================="
    cyan "  生成客户端配置"
    cyan "===================================="
    
    mkdir -p "$CLIENT_DIR"
    
    cat > "$CLIENT_DIR/client.json" <<EOF
{
    "log": {"loglevel": "warning"},
    "inbounds": [
        {
            "port": 1080,
            "listen": "127.0.0.1",
            "protocol": "socks",
            "settings": {"udp": true}
        }
    ],
    "outbounds": [
        {
            "protocol": "vless",
            "settings": {
                "vnext": [
                    {
                        "address": "$SERVER_IP",
                        "port": $LISTEN_PORT,
                        "users": [
                            {
                                "id": "$USER_UUID",
                                "encryption": "none"
                            }
                        ]
                    }
                ]
            },
            "streamSettings": {
                "network": "tcp",
                "security": "reality",
                "realitySettings": {
                    "fingerprint": "chrome",
                    "serverName": "$REALITY_DEST",
                    "publicKey": "$PUBLIC_KEY",
                    "shortId": "$SHORT_ID"
                }
            }
        }
    ]
}
EOF
    
    local link="vless://${USER_UUID}@${SERVER_IP}:${LISTEN_PORT}?encryption=none&security=reality&sni=${REALITY_DEST}&fp=chrome&pbk=${PUBLIC_KEY}&sid=${SHORT_ID}&type=tcp#VLESS-Reality"
    
    echo "$link" > "$CLIENT_DIR/share-link.txt"
    
    cat > "$CLIENT_DIR/info.txt" <<EOF
========================================
VLESS Reality 配置信息
========================================

服务器: $SERVER_IP
端口: $LISTEN_PORT
UUID: $USER_UUID
加密: none
传输: tcp
安全: reality
SNI: $REALITY_DEST
指纹: chrome
公钥: $PUBLIC_KEY
Short ID: $SHORT_ID

========================================
分享链接:
$link

========================================
客户端推荐:
- v2rayN (Windows)
- v2rayNG (Android)
- Shadowrocket (iOS)

生成时间: $(date)
========================================
EOF
    
    if command -v qrencode &>/dev/null; then
        qrencode -t ANSIUTF8 -o "$CLIENT_DIR/qr.txt" "$link" 2>/dev/null
        qrencode -t PNG -o "$CLIENT_DIR/qr.png" "$link" 2>/dev/null
    fi
    
    chmod 600 "$CLIENT_DIR"/*
    green "[✓] 配置已生成"
}

# 创建管理工具
create_management() {
    cat > /usr/local/bin/vless <<'SCRIPT'
#!/bin/bash
CLIENT_DIR="/root/vless-clients"
case "${1:-menu}" in
    start) systemctl start xray && echo "服务已启动" ;;
    stop) systemctl stop xray && echo "服务已停止" ;;
    restart) systemctl restart xray && echo "服务已重启" ;;
    status) systemctl status xray ;;
    log) journalctl -u xray -f ;;
    info) cat "$CLIENT_DIR/info.txt" 2>/dev/null || echo "配置不存在" ;;
    qr) 
        if [[ -f "$CLIENT_DIR/qr.txt" ]]; then
            cat "$CLIENT_DIR/qr.txt"
        else
            qrencode -t ANSIUTF8 < "$CLIENT_DIR/share-link.txt" 2>/dev/null || echo "二维码不存在"
        fi
        ;;
    link) cat "$CLIENT_DIR/share-link.txt" 2>/dev/null || echo "链接不存在" ;;
    *)
        echo "VLESS Reality 管理工具"
        echo ""
        echo "用法: vless [命令]"
        echo ""
        echo "命令:"
        echo "  start    - 启动服务"
        echo "  stop     - 停止服务"
        echo "  restart  - 重启服务"
        echo "  status   - 查看状态"
        echo "  log      - 查看日志"
        echo "  info     - 查看配置"
        echo "  qr       - 显示二维码"
        echo "  link     - 显示分享链接"
        ;;
esac
SCRIPT
    
    chmod +x /usr/local/bin/vless
    green "[✓] 管理工具已创建"
}

# 显示结果
show_result() {
    clear
    green "========================================"
    green "      安装完成！"
    green "========================================"
    echo ""
    cyan "【服务器信息】"
    echo "  IP: $SERVER_IP"
    echo "  端口: $LISTEN_PORT"
    echo ""
    cyan "【管理命令】"
    echo "  vless info     - 查看配置"
    echo "  vless qr       - 显示二维码"
    echo "  vless link     - 显示链接"
    echo "  vless status   - 查看状态"
    echo "  vless restart  - 重启服务"
    echo ""
    cyan "【配置目录】"
    echo "  $CLIENT_DIR"
    echo ""
    
    if [[ -f "$CLIENT_DIR/qr.txt" ]]; then
        cyan "【二维码】"
        cat "$CLIENT_DIR/qr.txt"
        echo ""
    fi
    
    cyan "【分享链接】"
    cat "$CLIENT_DIR/share-link.txt"
    echo ""
    
    yellow "提示: 配置已保存，使用 vless info 查看详细信息"
    echo ""
}

# 主函数
main() {
    clear
    cyan "╔════════════════════════════════════════╗"
    cyan "║   VLESS Reality 一键安装脚本 v3.0     ║"
    cyan "╚════════════════════════════════════════╝"
    echo ""
    
    check_root
    detect_system
    echo ""
    
    install_dependencies
    echo ""
    
    get_server_ip
    echo ""
    
    select_reality_target
    echo ""
    
    if ! install_xray; then
        red "安装失败"
        exit 1
    fi
    echo ""
    
    generate_keys
    echo ""
    
    configure_xray
    echo ""
    
    create_service
    echo ""
    
    setup_firewall
    echo ""
    
    optimize_system
    echo ""
    
    generate_client_config
    echo ""
    
    create_management
    echo ""
    
    show_result
}

main "$@"