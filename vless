#!/bin/bash

set -euo pipefail
export LANG=en_US.UTF-8

# 颜色定义
RED="\033[31m"
GREEN="\033[32m"
YELLOW="\033[33m"
BLUE="\033[34m"
PURPLE="\033[35m"
CYAN="\033[36m"
PLAIN="\033[0m"

red() { echo -e "${RED}$1${PLAIN}"; }
green() { echo -e "${GREEN}$1${PLAIN}"; }
yellow() { echo -e "${YELLOW}$1${PLAIN}"; }
blue() { echo -e "${BLUE}$1${PLAIN}"; }
purple() { echo -e "${PURPLE}$1${PLAIN}"; }
cyan() { echo -e "${CYAN}$1${PLAIN}"; }

# 配置目录
XRAY_DIR="/usr/local/etc/xray"
CLIENT_DIR="/root/vless-clients"
LOG_FILE="/var/log/xray/access.log"
ERROR_LOG="/var/log/xray/error.log"

# Reality 目标网站池（更新为高质量目标）
REALITY_TARGETS=(
    "www.microsoft.com:443"
    "www.apple.com:443"
    "www.cloudflare.com:443"
    "www.amazon.com:443"
    "addons.mozilla.org:443"
    "www.lovelive-anime.jp:443"
    "www.tesla.com:443"
    "www.cisco.com:443"
)

# 检查 root 权限
[[ $EUID -ne 0 ]] && red "[!] 请使用 root 用户运行本脚本！" && exit 1

# 全局变量
SERVER_IP=""
SERVER_IPV6=""
SYSTEM=""
VERSION=""
PKG_MANAGER=""
PKG_INSTALL=""
PKG_UPDATE=""
DOMAIN=""
USE_REAL_DOMAIN=false
REALITY_DEST=""
REALITY_PORT=443
REALITY_TARGET=""
USER_UUID=""
PRIVATE_KEY=""
PUBLIC_KEY=""
SHORT_ID=""
LISTEN_PORT=443

# 检测系统
detect_system() {
    if [[ -f /etc/os-release ]]; then
        source /etc/os-release
        SYSTEM="$ID"
        VERSION="$VERSION_ID"
    else
        red "[!] 无法检测系统类型"
        exit 1
    fi

    case $SYSTEM in
        "ubuntu"|"debian")
            PKG_MANAGER="apt"
            PKG_INSTALL="apt install -y"
            PKG_UPDATE="apt update -y"
            ;;
        "centos"|"rhel"|"fedora"|"rocky"|"almalinux")
            PKG_MANAGER="yum"
            PKG_INSTALL="yum install -y"
            PKG_UPDATE="yum update -y"
            [[ $SYSTEM == "centos" && ${VERSION%%.*} -le 7 ]] && PKG_INSTALL="yum install -y epel-release && yum install -y"
            ;;
        *)
            red "[!] 不支持的系统: $SYSTEM"
            exit 1
            ;;
    esac

    green "[✓] 系统检测: $SYSTEM $VERSION"
}

# 安装依赖
install_dependencies() {
    yellow "[*] 更新系统并安装依赖..."

    eval "$PKG_UPDATE" || true

    # 基础工具
    local packages="curl wget unzip tar qrencode jq bc net-tools openssl socat cron"
    
    if [[ "$SYSTEM" == "ubuntu" || "$SYSTEM" == "debian" ]]; then
        packages="$packages ufw certbot python3-certbot-nginx netcat-openbsd"
    else
        packages="$packages firewalld nmap-ncat"
    fi

    eval "$PKG_INSTALL $packages" || true

    # 时间同步（Reality 对时间敏感）
    if [[ "$SYSTEM" == "ubuntu" || "$SYSTEM" == "debian" ]]; then
        eval "$PKG_INSTALL systemd-timesyncd" || true
        systemctl enable --now systemd-timesyncd 2>/dev/null || true
    else
        eval "$PKG_INSTALL chrony" || true
        systemctl enable --now chronyd 2>/dev/null || true
    fi

    # 验证时间同步
    if command -v timedatectl &>/dev/null; then
        timedatectl set-ntp true 2>/dev/null || true
    fi

    green "[✓] 依赖安装完成"
}

# 获取服务器 IP
get_server_ip() {
    yellow "[*] 获取服务器公网 IP..."

    # 多源检测（按优先级排序）
    local ip_sources=(
        "https://api.ipify.org"
        "https://icanhazip.com"
        "https://ipinfo.io/ip"
        "https://ifconfig.me/ip"
        "https://checkip.amazonaws.com"
        "https://api.ip.sb/ip"
    )

    for source in "${ip_sources[@]}"; do
        yellow "[*] 尝试从 $source 获取..."
        SERVER_IP=$(curl -s4 --connect-timeout 3 --max-time 5 "$source" 2>/dev/null | grep -oE '^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$' | head -1)
        if [[ -n "$SERVER_IP" ]]; then
            green "[✓] 成功获取 IP"
            break
        fi
    done

    # 如果还是失败，尝试从网卡获取
    if [[ -z "$SERVER_IP" ]]; then
        yellow "[*] API 获取失败，尝试从网卡读取..."
        SERVER_IP=$(ip -4 addr show | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | grep -v '127.0.0.1' | head -1)
    fi

    # IPv6 检测（非关键，失败不影响）
    SERVER_IPV6=$(curl -s6 --connect-timeout 2 --max-time 3 "https://api6.ipify.org" 2>/dev/null | grep -oE '^([0-9a-fA-F]{0,4}:){7}[0-9a-fA-F]{0,4}$' | head -1 || true)

    if [[ -z "$SERVER_IP" ]]; then
        red "[!] 无法获取服务器 IP"
        red "[!] 请手动输入服务器 IP 地址"
        read -rp "请输入 IP: " SERVER_IP
        if [[ -z "$SERVER_IP" ]]; then
            red "[!] IP 不能为空"
            exit 1
        fi
    fi

    green "[✓] 服务器 IPv4: $SERVER_IP"
    [[ -n "$SERVER_IPV6" ]] && green "[✓] 服务器 IPv6: $SERVER_IPV6"
}

# 选择伪装域名
select_camouflage_domain() {
    echo ""
    blue "============================================"
    blue "  请选择伪装方式"
    blue "============================================"
    echo "1) IP 直连 (推荐，无需域名)"
    echo "2) 使用真实域名 (需要提前解析)"
    echo "3) 自动生成伪装域名"
    echo ""

    read -rp "请选择 [1-3, 默认1]: " choice
    choice=${choice:-1}

    case $choice in
        1)
            DOMAIN="$SERVER_IP"
            USE_REAL_DOMAIN=false
            green "[✓] 使用 IP 直连模式"
            ;;
        2)
            read -rp "请输入你的域名: " DOMAIN
            if [[ -z "$DOMAIN" ]]; then
                red "[!] 域名不能为空"
                exit 1
            fi
            USE_REAL_DOMAIN=true
            green "[✓] 使用域名: $DOMAIN"
            ;;
        3)
            local prefixes=("cdn" "api" "static" "edge" "assets" "content")
            local domains=("cloudfront.net" "amazonaws.com" "googleapis.com" "fastly.net" "akamaized.net")
            local rand_prefix=${prefixes[$RANDOM % ${#prefixes[@]}]}
            local rand_num=$((10000 + RANDOM % 90000))
            local rand_domain=${domains[$RANDOM % ${#domains[@]}]}
            DOMAIN="$rand_prefix-$rand_num.$rand_domain"
            USE_REAL_DOMAIN=false
            green "[✓] 生成伪装域名: $DOMAIN"
            ;;
    esac
}

# 选择 Reality 目标
select_reality_target() {
    echo ""
    blue "============================================"
    blue "  选择 Reality 目标网站"
    blue "============================================"
    
    for i in "${!REALITY_TARGETS[@]}"; do
        echo "$((i+1))) ${REALITY_TARGETS[i]}"
    done
    echo "$((${#REALITY_TARGETS[@]}+1))) 自定义"
    echo ""

    read -rp "请选择 [1-$((${#REALITY_TARGETS[@]}+1)), 默认1]: " target_choice
    target_choice=${target_choice:-1}

    if [[ $target_choice -eq $((${#REALITY_TARGETS[@]}+1)) ]]; then
        read -rp "输入自定义目标 (格式: domain:port): " REALITY_TARGET
        if [[ ! "$REALITY_TARGET" =~ ^[^:]+:[0-9]+$ ]]; then
            yellow "[!] 格式错误，使用默认目标"
            REALITY_TARGET="${REALITY_TARGETS[0]}"
        fi
    else
        idx=$((target_choice - 1))
        [[ $idx -lt 0 || $idx -ge ${#REALITY_TARGETS[@]} ]] && idx=0
        REALITY_TARGET="${REALITY_TARGETS[$idx]}"
    fi

    REALITY_DEST="${REALITY_TARGET%%:*}"
    REALITY_PORT="${REALITY_TARGET##*:}"

    green "[✓] Reality 目标: $REALITY_DEST:$REALITY_PORT"

    # 测试连通性
    if command -v nc &>/dev/null; then
        if timeout 3 nc -zv "$REALITY_DEST" "$REALITY_PORT" &>/dev/null; then
            green "[✓] 目标网站连通性正常"
        else
            yellow "[!] 警告: 目标网站可能无法访问"
        fi
    fi
}

# 安装 Xray
install_xray() {
    yellow "[*] 安装 Xray-core 最新版..."

    # 获取最新版本
    local latest_version
    if command -v jq &>/dev/null; then
        latest_version=$(timeout 10 curl -s "https://api.github.com/repos/XTLS/Xray-core/releases/latest" | jq -r '.tag_name' | sed 's/v//')
    fi
    
    [[ -z "$latest_version" ]] && latest_version="1.8.10"

    # 检测架构
    local arch=$(uname -m)
    case $arch in
        x86_64) arch="64" ;;
        aarch64) arch="arm64-v8a" ;;
        armv7l) arch="arm32-v7a" ;;
        *) red "[!] 不支持的架构: $arch"; exit 1 ;;
    esac

    # 下载 Xray
    local download_url="https://github.com/XTLS/Xray-core/releases/download/v${latest_version}/Xray-linux-${arch}.zip"
    local proxy_url="https://ghproxy.com/${download_url}"

    cd /tmp || exit 1
    
    if ! timeout 30 wget -q --show-progress -O xray.zip "$download_url" 2>/dev/null; then
        yellow "[*] 主源失败，使用代理下载..."
        if ! timeout 30 wget -q --show-progress -O xray.zip "$proxy_url" 2>/dev/null; then
            red "[!] 下载失败，请检查网络"
            return 1
        fi
    fi

    # 解压并安装
    unzip -oq xray.zip 2>/dev/null || true
    mkdir -p /usr/local/bin /usr/local/etc/xray /var/log/xray /usr/local/share/xray

    if [[ -f ./xray ]]; then
        mv -f xray /usr/local/bin/
    fi
    
    [[ -f ./geoip.dat ]] && mv -f geoip.dat /usr/local/share/xray/
    [[ -f ./geosite.dat ]] && mv -f geosite.dat /usr/local/share/xray/

    chmod +x /usr/local/bin/xray

    # 验证安装
    if /usr/local/bin/xray version &>/dev/null; then
        local version_info=$(/usr/local/bin/xray version | head -1)
        green "[✓] Xray 安装成功: $version_info"
    else
        red "[!] Xray 安装失败"
        return 1
    fi

    # 清理
    rm -rf /tmp/xray* /tmp/Xray*
    return 0
}

# 生成密钥
generate_keys() {
    yellow "[*] 生成密钥和配置..."

    # UUID
    if command -v uuidgen &>/dev/null; then
        USER_UUID=$(uuidgen | tr 'A-Z' 'a-z')
    else
        USER_UUID=$(cat /proc/sys/kernel/random/uuid)
    fi

    # Reality 密钥对
    local key_output
    key_output=$(/usr/local/bin/xray x25519 2>/dev/null)
    PRIVATE_KEY=$(echo "$key_output" | grep -i "Private key" | awk '{print $3}')
    PUBLIC_KEY=$(echo "$key_output" | grep -i "Public key" | awk '{print $3}')

    if [[ -z "$PRIVATE_KEY" || -z "$PUBLIC_KEY" ]]; then
        red "[!] 无法生成 Reality 密钥"
        exit 1
    fi

    # 生成 Short ID (8位或16位)
    SHORT_ID=$(openssl rand -hex 8)

    # 选择端口
    if ss -tlnp 2>/dev/null | grep -q ":443 "; then
        LISTEN_PORT=$(shuf -i 10000-60000 -n 1)
        while ss -tlnp 2>/dev/null | grep -q ":$LISTEN_PORT "; do
            LISTEN_PORT=$(shuf -i 10000-60000 -n 1)
        done
        yellow "[*] 端口 443 被占用，使用端口: $LISTEN_PORT"
    else
        LISTEN_PORT=443
    fi

    # 保存密钥
    mkdir -p "$XRAY_DIR"
    cat > "$XRAY_DIR/keys.txt" <<EOF
UUID: $USER_UUID
Private Key: $PRIVATE_KEY
Public Key: $PUBLIC_KEY
Short ID: $SHORT_ID
Listen Port: $LISTEN_PORT
Reality Target: $REALITY_DEST:$REALITY_PORT
Generated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
EOF
    chmod 600 "$XRAY_DIR/keys.txt"

    green "[✓] 密钥生成完成"
    green "[✓] UUID: $USER_UUID"
    green "[✓] 端口: $LISTEN_PORT"
}

# 配置 Xray (增强版)
configure_xray_server() {
    yellow "[*] 配置 Xray 服务器..."

    mkdir -p "$XRAY_DIR" /var/log/xray

    cat > "$XRAY_DIR/config.json" <<EOF
{
    "log": {
        "access": "$LOG_FILE",
        "error": "$ERROR_LOG",
        "loglevel": "warning",
        "dnsLog": false
    },
    "inbounds": [
        {
            "listen": "0.0.0.0",
            "port": $LISTEN_PORT,
            "protocol": "vless",
            "settings": {
                "clients": [
                    {
                        "id": "$USER_UUID",
                        "flow": ""
                    }
                ],
                "decryption": "none",
                "fallbacks": []
            },
            "streamSettings": {
                "network": "tcp",
                "security": "reality",
                "realitySettings": {
                    "show": false,
                    "dest": "$REALITY_DEST:$REALITY_PORT",
                    "xver": 0,
                    "serverNames": [
                        "$REALITY_DEST"
                    ],
                    "privateKey": "$PRIVATE_KEY",
                    "minClientVer": "",
                    "maxClientVer": "",
                    "maxTimeDiff": 0,
                    "shortIds": [
                        "$SHORT_ID",
                        ""
                    ]
                },
                "tcpSettings": {
                    "acceptProxyProtocol": false
                }
            },
            "sniffing": {
                "enabled": true,
                "destOverride": [
                    "http",
                    "tls",
                    "quic"
                ],
                "routeOnly": false
            }
        }
    ],
    "outbounds": [
        {
            "protocol": "freedom",
            "settings": {
                "domainStrategy": "UseIPv4"
            },
            "tag": "direct"
        },
        {
            "protocol": "blackhole",
            "settings": {
                "response": {
                    "type": "http"
                }
            },
            "tag": "block"
        }
    ],
    "routing": {
        "domainStrategy": "IPIfNonMatch",
        "rules": [
            {
                "type": "field",
                "ip": [
                    "geoip:private"
                ],
                "outboundTag": "block"
            },
            {
                "type": "field",
                "domain": [
                    "geosite:category-ads-all"
                ],
                "outboundTag": "block"
            }
        ]
    },
    "policy": {
        "levels": {
            "0": {
                "handshake": 4,
                "connIdle": 300,
                "uplinkOnly": 2,
                "downlinkOnly": 5,
                "statsUserUplink": false,
                "statsUserDownlink": false,
                "bufferSize": 512
            }
        },
        "system": {
            "statsInboundUplink": false,
            "statsInboundDownlink": false,
            "statsOutboundUplink": false,
            "statsOutboundDownlink": false
        }
    }
}
EOF

    chmod 644 "$XRAY_DIR/config.json"

    # 验证配置
    if /usr/local/bin/xray -test -config="$XRAY_DIR/config.json" &>/dev/null; then
        green "[✓] 配置文件验证通过"
    else
        red "[!] 配置文件验证失败"
        /usr/local/bin/xray -test -config="$XRAY_DIR/config.json"
        exit 1
    fi
}

# 创建 systemd 服务
create_systemd_service() {
    yellow "[*] 创建 Xray 系统服务..."

    cat > /etc/systemd/system/xray.service <<EOF
[Unit]
Description=Xray Service (VLESS Reality)
Documentation=https://github.com/xtls/xray-core
After=network.target nss-lookup.target network-online.target
Wants=network-online.target

[Service]
Type=simple
User=root
CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE
AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE
NoNewPrivileges=true
ExecStart=/usr/local/bin/xray run -config /usr/local/etc/xray/config.json
Restart=on-failure
RestartPreventExitStatus=23
RestartSec=10s
LimitNPROC=10000
LimitNOFILE=1000000

[Install]
WantedBy=multi-user.target
EOF

    systemctl daemon-reload
    systemctl enable xray
    systemctl start xray

    sleep 2

    if systemctl is-active --quiet xray; then
        green "[✓] Xray 服务启动成功"
    else
        red "[!] Xray 服务启动失败"
        journalctl -u xray --no-pager -n 20
        exit 1
    fi
}

# 配置防火墙
configure_firewall() {
    yellow "[*] 配置防火墙..."

    if command -v ufw &>/dev/null; then
        ufw --force enable
        ufw default deny incoming
        ufw default allow outgoing
        ufw allow ssh
        ufw allow $LISTEN_PORT/tcp comment 'VLESS Reality'
        ufw reload
        green "[✓] UFW 防火墙配置完成"
    elif command -v firewall-cmd &>/dev/null; then
        systemctl enable --now firewalld
        firewall-cmd --permanent --add-port=$LISTEN_PORT/tcp
        firewall-cmd --permanent --add-service=ssh
        firewall-cmd --reload
        green "[✓] Firewalld 防火墙配置完成"
    else
        yellow "[!] 未检测到防火墙，跳过配置"
    fi
}

# 生成客户端配置
generate_client_configs() {
    yellow "[*] 生成客户端配置..."

    mkdir -p "$CLIENT_DIR"

    # 客户端 JSON 配置
    cat > "$CLIENT_DIR/client.json" <<EOF
{
    "log": {
        "loglevel": "warning"
    },
    "inbounds": [
        {
            "port": 1080,
            "listen": "127.0.0.1",
            "protocol": "socks",
            "settings": {
                "udp": true,
                "auth": "noauth"
            }
        },
        {
            "port": 1081,
            "listen": "127.0.0.1",
            "protocol": "http"
        }
    ],
    "outbounds": [
        {
            "protocol": "vless",
            "settings": {
                "vnext": [
                    {
                        "address": "$SERVER_IP",
                        "port": $LISTEN_PORT,
                        "users": [
                            {
                                "id": "$USER_UUID",
                                "encryption": "none",
                                "flow": ""
                            }
                        ]
                    }
                ]
            },
            "streamSettings": {
                "network": "tcp",
                "security": "reality",
                "realitySettings": {
                    "show": false,
                    "fingerprint": "chrome",
                    "serverName": "$REALITY_DEST",
                    "publicKey": "$PUBLIC_KEY",
                    "shortId": "$SHORT_ID",
                    "spiderX": ""
                }
            },
            "tag": "proxy"
        },
        {
            "protocol": "freedom",
            "tag": "direct"
        }
    ],
    "routing": {
        "domainStrategy": "IPIfNonMatch",
        "rules": [
            {
                "type": "field",
                "domain": ["geosite:cn"],
                "outboundTag": "direct"
            },
            {
                "type": "field",
                "ip": ["geoip:cn", "geoip:private"],
                "outboundTag": "direct"
            }
        ]
    }
}
EOF

    # 生成分享链接
    local vless_link="vless://${USER_UUID}@${SERVER_IP}:${LISTEN_PORT}?encryption=none&flow=&security=reality&sni=${REALITY_DEST}&fp=chrome&pbk=${PUBLIC_KEY}&sid=${SHORT_ID}&type=tcp&headerType=none#VLESS-Reality-$(date +%s)"

    echo "$vless_link" > "$CLIENT_DIR/share-link.txt"

    # 生成二维码
    if command -v qrencode &>/dev/null; then
        qrencode -t PNG -o "$CLIENT_DIR/qrcode.png" "$vless_link"
    fi

    # 客户端信息
    cat > "$CLIENT_DIR/client-info.txt" <<EOF
╔════════════════════════════════════════════════════════════════╗
║           VLESS Reality 客户端配置信息                          ║
╚════════════════════════════════════════════════════════════════╝

【连接信息】
┌────────────────────────────────────────────────────────────────
│ 服务器地址: $SERVER_IP
│ 端口: $LISTEN_PORT
│ UUID: $USER_UUID
│ 加密: none
│ 传输协议: tcp
│ 安全层: reality
│ SNI: $REALITY_DEST
│ 指纹: chrome
│ 公钥: $PUBLIC_KEY
│ Short ID: $SHORT_ID
└────────────────────────────────────────────────────────────────

【分享链接】
$vless_link

【客户端推荐】
• v2rayN (Windows) - https://github.com/2dust/v2rayN
• v2rayNG (Android) - https://github.com/2dust/v2rayNG
• Shadowrocket (iOS)
• Qv2ray (跨平台)
• sing-box (推荐)

【本地代理端口】
• SOCKS5: 127.0.0.1:1080
• HTTP: 127.0.0.1:1081

【配置文件位置】
• JSON: $CLIENT_DIR/client.json
• 二维码: $CLIENT_DIR/qrcode.png
• 分享链接: $CLIENT_DIR/share-link.txt

生成时间: $(date "+%Y-%m-%d %H:%M:%S")
EOF

    chmod 600 "$CLIENT_DIR"/*
    green "[✓] 客户端配置生成完成"
}

# 系统优化
optimize_system() {
    yellow "[*] 优化系统性能..."

    # BBR 加速
    if ! grep -q "net.core.default_qdisc=fq" /etc/sysctl.conf; then
        cat >> /etc/sysctl.conf <<EOF

# VLESS Reality 优化
net.core.default_qdisc=fq
net.ipv4.tcp_congestion_control=bbr
net.ipv4.tcp_fastopen=3
net.ipv4.tcp_slow_start_after_idle=0
net.ipv4.tcp_keepalive_time=600
net.ipv4.tcp_keepalive_intvl=30
net.ipv4.tcp_keepalive_probes=3
net.core.rmem_max=134217728
net.core.wmem_max=134217728
net.ipv4.tcp_rmem=4096 87380 67108864
net.ipv4.tcp_wmem=4096 65536 67108864
net.core.netdev_max_backlog=5000
net.ipv4.tcp_max_syn_backlog=8192
net.ipv4.ip_forward=1
fs.file-max=1048576
EOF
        sysctl -p &>/dev/null
    fi

    # 文件描述符限制
    if ! grep -q "root soft nofile" /etc/security/limits.conf; then
        cat >> /etc/security/limits.conf <<EOF
* soft nofile 1048576
* hard nofile 1048576
root soft nofile 1048576
root hard nofile 1048576
EOF
    fi

    green "[✓] 系统优化完成"
}

# 创建管理脚本
create_management_script() {
    yellow "[*] 创建管理工具..."

    cat > /usr/local/bin/vless <<'SCRIPT'
#!/bin/bash

RED="\033[31m"
GREEN="\033[32m"
YELLOW="\033[33m"
BLUE="\033[34m"
PLAIN="\033[0m"

CLIENT_DIR="/root/vless-clients"
LOG_FILE="/var/log/xray/access.log"
ERROR_LOG="/var/log/xray/error.log"

show_menu() {
    clear
    echo -e "${BLUE}╔════════════════════════════════════════╗${PLAIN}"
    echo -e "${BLUE}║   VLESS Reality 管理工具 v2.0         ║${PLAIN}"
    echo -e "${BLUE}╚════════════════════════════════════════╝${PLAIN}"
    echo ""
    echo -e "${GREEN}1.${PLAIN} 查看服务状态"
    echo -e "${GREEN}2.${PLAIN} 查看连接信息"
    echo -e "${GREEN}3.${PLAIN} 显示二维码"
    echo -e "${GREEN}4.${PLAIN} 查看日志"
    echo -e "${GREEN}5.${PLAIN} 重启服务"
    echo -e "${GREEN}6.${PLAIN} 停止服务"
    echo -e "${GREEN}7.${PLAIN} 启动服务"
    echo -e "${GREEN}0.${PLAIN} 退出"
    echo ""
}

show_status() {
    echo -e "${BLUE}=== 服务状态 ===${PLAIN}"
    systemctl status xray --no-pager -l
    echo ""
    if [[ -f "$LOG_FILE" ]]; then
        echo -e "${BLUE}=== 连接统计 ===${PLAIN}"
        echo "活跃连接: $(ss -tn | grep ESTAB | wc -l)"
        echo "今日访问: $(grep "$(date +%Y/%m/%d)" "$LOG_FILE" 2>/dev/null | wc -l)"
    fi
}

show_config() {
    if [[ -f "$CLIENT_DIR/client-info.txt" ]]; then
        cat "$CLIENT_DIR/client-info.txt"
    else
        echo -e "${RED}配置文件不存在${PLAIN}"
    fi
}

show_qr() {
    if [[ -f "$CLIENT_DIR/share-link.txt" ]]; then
        qrencode -t ANSIUTF8 < "$CLIENT_DIR/share-link.txt"
        echo ""
        cat "$CLIENT_DIR/share-link.txt"
    else
        echo -e "${RED}分享链接不存在${PLAIN}"
    fi
}

view_logs() {
    echo -e "${BLUE}=== 最近 50 行日志 ===${PLAIN}"
    echo ""
    echo -e "${YELLOW}[访问日志]${PLAIN}"
    tail -30 "$LOG_FILE" 2>/dev/null || echo "无日志"
    echo ""
    echo -e "${YELLOW}[错误日志]${PLAIN}"
    tail -20 "$ERROR_LOG" 2>/dev/null || echo "无错误"
}

restart_service() {
    echo -e "${YELLOW}正在重启 Xray 服务...${PLAIN}"
    systemctl restart xray
    sleep 2
    if systemctl is-active --quiet xray; then
        echo -e "${GREEN}✓ 服务重启成功${PLAIN}"
    else
        echo -e "${RED}✗ 服务重启失败${PLAIN}"
        systemctl status xray --no-pager -l
    fi
}

stop_service() {
    echo -e "${YELLOW}正在停止 Xray 服务...${PLAIN}"
    systemctl stop xray
    echo -e "${GREEN}✓ 服务已停止${PLAIN}"
}

start_service() {
    echo -e "${YELLOW}正在启动 Xray 服务...${PLAIN}"
    systemctl start xray
    sleep 2
    if systemctl is-active --quiet xray; then
        echo -e "${GREEN}✓ 服务启动成功${PLAIN}"
    else
        echo -e "${RED}✗ 服务启动失败${PLAIN}"
    fi
}

if [[ $# -eq 0 ]]; then
    while true; do
        show_menu
        read -rp "请选择操作 [0-7]: " choice
        case $choice in
            1) show_status ;;
            2) show_config ;;
            3) show_qr ;;
            4) view_logs ;;
            5) restart_service ;;
            6) stop_service ;;
            7) start_service ;;
            0) exit 0 ;;
            *) echo -e "${RED}无效选项${PLAIN}" ;;
        esac
        echo ""
        read -rp "按回车键继续..."
    done
else
    case "$1" in
        status|st) show_status ;;
        config|cfg) show_config ;;
        qr) show_qr ;;
        log|logs) view_logs ;;
        restart|rs) restart_service ;;
        stop) stop_service ;;
        start) start_service ;;
        *) 
            echo "用法: vless [status|config|qr|log|restart|stop|start]"
            echo "或直接运行 vless 进入交互菜单"
            ;;
    esac
fi
SCRIPT

    chmod +x /usr/local/bin/vless
    green "[✓] 管理工具已创建: vless"
}

# 显示安装完成信息
show_completion_info() {
    clear
    green "╔════════════════════════════════════════════════════════════════╗"
    green "║                    安装完成！                                   ║"
    green "╚════════════════════════════════════════════════════════════════╝"
    echo ""
    cyan "【服务器信息】"
    echo "  IP 地址: $SERVER_IP"
    echo "  监听端口: $LISTEN_PORT"
    echo "  Reality 目标: $REALITY_DEST:$REALITY_PORT"
    echo ""
    cyan "【管理命令】"
    echo "  vless          - 打开管理菜单"
    echo "  vless status   - 查看服务状态"
    echo "  vless config   - 查看配置信息"
    echo "  vless qr       - 显示二维码"
    echo "  vless restart  - 重启服务"
    echo ""
    cyan "【客户端配置】"
    echo "  配置目录: $CLIENT_DIR"
    echo "  JSON 配置: $CLIENT_DIR/client.json"
    echo "  二维码: $CLIENT_DIR/qrcode.png"
    echo ""
    cyan "【分享链接】"
    if [[ -f "$CLIENT_DIR/share-link.txt" ]]; then
        cat "$CLIENT_DIR/share-link.txt"
    fi
    echo ""
    cyan "【系统服务】"
    echo "  查看状态: systemctl status xray"
    echo "  重启服务: systemctl restart xray"
    echo "  查看日志: journalctl -u xray -f"
    echo ""
    
    if command -v qrencode &>/dev/null && [[ -f "$CLIENT_DIR/share-link.txt" ]]; then
        echo ""
        cyan "【连接二维码】"
        qrencode -t ANSIUTF8 < "$CLIENT_DIR/share-link.txt"
    fi
    
    echo ""
    yellow "提示: 请保存好配置信息，客户端配置文件在 $CLIENT_DIR 目录"
    echo ""
}

# 主函数
main() {
    clear
    cyan "╔════════════════════════════════════════════════════════════════╗"
    cyan "║          VLESS Reality 一键安装脚本 (优化增强版)              ║"
    cyan "║                     Version 2.0                                ║"
    cyan "╚════════════════════════════════════════════════════════════════╝"
    echo ""
    
    detect_system
    install_dependencies
    get_server_ip
    select_camouflage_domain
    select_reality_target
    
    if ! install_xray; then
        red "[!] Xray 安装失败，脚本退出"
        exit 1
    fi
    
    generate_keys
    configure_xray_server
    create_systemd_service
    configure_firewall
    generate_client_configs
    optimize_system
    create_management_script
    
    show_completion_info
}

# 脚本入口
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi