#!/bin/bash

set -euo pipefail
export LANG=en_US.UTF-8

RED="\033[31m"
GREEN="\033[32m"
YELLOW="\033[33m"
BLUE="\033[34m"
PURPLE="\033[35m"
CYAN="\033[36m"
PLAIN="\033[0m"

red() { echo -e "${RED}$1${PLAIN}"; }
green() { echo -e "${GREEN}$1${PLAIN}"; }
yellow() { echo -e "${YELLOW}$1${PLAIN}"; }
blue() { echo -e "${BLUE}$1${PLAIN}"; }
purple() { echo -e "${PURPLE}$1${PLAIN}"; }
cyan() { echo -e "${CYAN}$1${PLAIN}"; }

# 配置目录
XRAY_DIR="/usr/local/etc/xray"
CLIENT_DIR="/root/vless-clients"
LOG_FILE="/var/log/xray/access.log"
ERROR_LOG="/var/log/xray/error.log"
NGINX_CONF_DIR="/etc/nginx"

# Reality 目标网站池 (知名网站，流量特征相似)
REALITY_TARGETS=(
    "www.microsoft.com:443"
    "www.apple.com:443"
    "www.cloudflare.com:443"
    "www.github.com:443"
    "www.docker.com:443"
    "www.ubuntu.com:443"
    "www.mozilla.org:443"
    "nodejs.org:443"
)

[[ $EUID -ne 0 ]] && red "[!] 请使用 root 用户运行本脚本！" && exit 1

# 全局变量会在运行时填充
SERVER_IP=""
SERVER_IPV6=""
SYSTEM=""
VERSION=""
PKG_MANAGER=""
PKG_INSTALL=""
PKG_UPDATE=""
DOMAIN=""
USE_REAL_DOMAIN=false
REALITY_DEST=""
REALITY_PORT=443
REALITY_TARGET=""
USER_UUID=""
PRIVATE_KEY=""
PUBLIC_KEY=""
SHORT_ID=""
LISTEN_PORT=443
PUBLIC_KEY=""

# 检测系统
detect_system() {
    if [[ -f /etc/os-release ]]; then
        source /etc/os-release
        SYSTEM="$ID"
        VERSION="$VERSION_ID"
    else
        red "[!] 无法检测系统类型"
        exit 1
    fi

    case $SYSTEM in
        "ubuntu"|"debian")
            PKG_MANAGER="apt"
            PKG_INSTALL="apt install -y"
            PKG_UPDATE="apt update -y && apt upgrade -y"
            ;;
        "centos"|"rhel"|"fedora"|"rocky"|"almalinux")
            PKG_MANAGER="yum"
            PKG_INSTALL="yum install -y"
            PKG_UPDATE="yum update -y"
            if [[ $SYSTEM == "centos" ]]; then
                PKG_INSTALL="yum install -y epel-release && yum install -y"
            fi
            ;;
        *)
            red "[!] 不支持的系统: $SYSTEM"
            exit 1
            ;;
    esac

    yellow "[*] 检测到系统: $SYSTEM $VERSION"
}

# 安装依赖
install_dependencies() {
    yellow "[*] 更新系统并安装依赖..."

    eval "$PKG_UPDATE"

    # 基础工具
    eval "$PKG_INSTALL curl wget unzip tar qrencode nginx certbot \
                 python3-certbot-nginx ufw fail2ban jq bc \
                 net-tools dnsutils openssl socat cron nmap nc"

    # 时间同步 (Reality 对时间敏感)
    if command -v chronyd >/dev/null 2>&1 || systemctl list-unit-files | grep -q chrony; then
        eval "$PKG_INSTALL chrony" || true
        systemctl enable --now chronyd 2>/dev/null || systemctl enable --now chrony 2>/dev/null || true
    else
        eval "$PKG_INSTALL ntp" || true
        systemctl enable --now ntpd 2>/dev/null || true
    fi

    # 配置 fail2ban
    if command -v fail2ban-server >/dev/null 2>&1; then
        systemctl enable --now fail2ban || true

        # 配置 Xray 防护规则
        cat > /etc/fail2ban/filter.d/xray.conf <<EOF
[Definition]
failregex = .*rejected.* from <HOST>:.*
            .*invalid.* from <HOST>:.*
            .*failed.* from <HOST>:.*
ignoreregex =
EOF

        cat > /etc/fail2ban/jail.d/xray.conf <<EOF
[xray]
enabled = true
port = 80,443
filter = xray
logpath = $ERROR_LOG
maxretry = 3
bantime = 3600
findtime = 600
EOF

        systemctl restart fail2ban || true
    fi
}

# 获取服务器 IP
get_server_ip() {
    yellow "[*] 获取服务器公网 IP..."

    # 多源IP检测，增加可靠性
    IP_SOURCES=(
        "https://api.ipify.org"
        "https://icanhazip.com"
        "https://ipv4.icanhazip.com"
        "https://checkip.amazonaws.com"
        "https://ifconfig.me/ip"
    )

    for source in "${IP_SOURCES[@]}"; do
        SERVER_IP=$(curl -s --connect-timeout 5 --max-time 10 "$source" 2>/dev/null | grep -E '^[0-9.]+$' || true)
        [[ -n "$SERVER_IP" ]] && break
    done

    # IPv6 支持检测
    SERVER_IPV6=$(curl -s --connect-timeout 5 --max-time 10 "https://ipv6.icanhazip.com" 2>/dev/null | grep -E '^[0-9a-fA-F:]+$' || true)

    if [[ -z "$SERVER_IP" ]]; then
        red "[!] 无法获取服务器公网 IP"
        exit 1
    fi

    yellow "[*] 服务器 IPv4: $SERVER_IP"
    [[ -n "$SERVER_IPV6" ]] && yellow "[*] 服务器 IPv6: $SERVER_IPV6"
}

# 选择伪装域名
select_camouflage_domain() {
    yellow "[*] 选择伪装策略..."

    echo ""
    blue "请选择伪装方式:"
    echo "1) 使用真实域名 (需要域名和证书)"
    echo "2) 使用 IP 直连 (无需域名，纯 Reality)"
    echo "3) 自动生成假域名 (推荐)"
    echo ""

    read -rp "请选择 [1-3, 默认3]: " camouflage_choice
    camouflage_choice=${camouflage_choice:-3}

    case $camouflage_choice in
        1)
            read -rp "请输入你的域名: " DOMAIN
            if [[ -z "$DOMAIN" ]]; then
                red "[!] 域名不能为空"
                exit 1
            fi
            USE_REAL_DOMAIN=true
            ;;
        2)
            DOMAIN="$SERVER_IP"
            USE_REAL_DOMAIN=false
            ;;
        3)
            # 生成看起来真实的假域名
            FAKE_DOMAINS=(
                "cdn-$((RANDOM % 9999)).cloudfront.net"
                "api-$((RANDOM % 9999)).amazonaws.com"
                "static-$((RANDOM % 9999)).googleapis.com"
                "assets-$((RANDOM % 9999)).github.io"
                "edge-$((RANDOM % 9999)).fastly.com"
            )
            DOMAIN=${FAKE_DOMAINS[$((RANDOM % ${#FAKE_DOMAINS[@]}))]}
            USE_REAL_DOMAIN=false
            yellow "[*] 生成的伪装域名: $DOMAIN"
            ;;
        *)
            yellow "[*] 使用默认模式"
            DOMAIN="$SERVER_IP"
            USE_REAL_DOMAIN=false
            ;;
    esac
}

# 选择 Reality 目标网站
select_reality_target() {
    yellow "[*] 选择 Reality 目标网站..."

    echo ""
    blue "可用的目标网站:"
    for i in "${!REALITY_TARGETS[@]}"; do
        echo "$((i+1))) ${REALITY_TARGETS[i]}"
    done
    echo "$((${#REALITY_TARGETS[@]}+1))) 自定义"
    echo ""

    read -rp "请选择目标网站 [1-$((${#REALITY_TARGETS[@]}+1)), 默认1]: " target_choice
    target_choice=${target_choice:-1}

    if [[ $target_choice -eq $((${#REALITY_TARGETS[@]}+1)) ]]; then
        read -rp "请输入自定义目标 (格式: domain:port): " REALITY_TARGET
        if [[ ! "$REALITY_TARGET" =~ ^[^:]+:[0-9]+$ ]]; then
            red "[!] 格式错误，使用默认目标"
            REALITY_TARGET="${REALITY_TARGETS[0]}"
        fi
    else
        REALITY_TARGET="${REALITY_TARGETS[$((target_choice-1))]}"
    fi

    REALITY_DEST="${REALITY_TARGET%:*}"
    REALITY_PORT="${REALITY_TARGET#*:}"

    yellow "[*] Reality 目标: $REALITY_DEST:$REALITY_PORT"

    # 测试目标连通性（非致命）
    if command -v nc >/dev/null 2>&1; then
        if ! nc -z -w3 "$REALITY_DEST" "$REALITY_PORT" 2>/dev/null; then
            yellow "[!] 警告: 目标网站可能无法访问，但不影响使用"
        fi
    fi
}

# 安装 Xray
install_xray() {
    yellow "[*] 安装 Xray-core..."

    # 获取最新版本（使用 GitHub API 需要 jq）
    if command -v jq >/dev/null 2>&1; then
        LATEST_VERSION=$(curl -s "https://api.github.com/repos/XTLS/Xray-core/releases/latest" | jq -r '.tag_name' | sed 's/v//') || true
    fi

    if [[ -z "${LATEST_VERSION:-}" ]]; then
        # 兜底版本，如果无法获取最新版本则使用预设（脚本不依赖特定版本）
        LATEST_VERSION="1.7.5" || true
        yellow "[*] 未能在线获取最新版本，使用内置版本号: $LATEST_VERSION"
    else
        yellow "[*] 最新版本: $LATEST_VERSION"
    fi

    # 检测系统架构
    ARCH=$(uname -m)
    case $ARCH in
        x86_64) ARCH="64" ;;
        aarch64) ARCH="arm64-v8a" ;;
        armv7l) ARCH="arm32-v7a" ;;
        *) red "[!] 不支持的架构: $ARCH"; exit 1 ;;
    esac

    # 下载并安装
    DOWNLOAD_URL="https://github.com/XTLS/Xray-core/releases/download/v$LATEST_VERSION/Xray-linux-$ARCH.zip"

    cd /tmp || exit 1
    if ! wget -O xray.zip "$DOWNLOAD_URL" 2>/dev/null; then
        yellow "[*] 主源下载失败，尝试备用源..."
        if ! wget -O xray.zip "https://ghproxy.com/$DOWNLOAD_URL" 2>/dev/null; then
            red "[!] 下载失败，请检查网络或手动安装 Xray"; return 1
        fi
    fi

    unzip -o xray.zip || true

    # 安装文件
    mkdir -p /usr/local/bin /usr/local/etc/xray /var/log/xray
    if [[ -f ./xray ]]; then
        mv -f xray /usr/local/bin/ || true
    elif [[ -f ./Xray-linux-$ARCH/xray ]]; then
        mv -f ./Xray-linux-$ARCH/xray /usr/local/bin/ || true
    fi
    chmod +x /usr/local/bin/xray || true

    # 验证安装
    if command -v /usr/local/bin/xray >/dev/null 2>&1 && /usr/local/bin/xray version 2>/dev/null | grep -q "Xray"; then
        green "[*] Xray 安装成功: $(/usr/local/bin/xray version | head -1 2>/dev/null || true)"
    else
        red "[!] Xray 安装失败，请检查 /usr/local/bin/xray 是否存在"
        return 1
    fi

    # 清理临时文件
    rm -rf /tmp/xray.zip /tmp/xray* /tmp/Xray-linux-* || true
}

# 生成密钥和 UUID
generate_keys() {
    yellow "[*] 生成密钥和配置..."

    # 生成 UUID
    USER_UUID=$(cat /proc/sys/kernel/random/uuid)

    # 生成 Reality 密钥对（x25519）
    if command -v /usr/local/bin/xray >/dev/null 2>&1; then
        KEY_PAIR=$(/usr/local/bin/xray x25519 2>/dev/null || true)
    fi
    PRIVATE_KEY=$(echo "$KEY_PAIR" | grep -i "Private" | awk '{print $3}' || true)
    PUBLIC_KEY=$(echo "$KEY_PAIR" | grep -i "Public" | awk '{print $3}' || true)

    # 如果 xray 无法生成密钥，使用 openssl 生成 x25519 私钥并导出公钥（兼容性有限）
    if [[ -z "$PRIVATE_KEY" || -z "$PUBLIC_KEY" ]]; then
        yellow "[*] 无法通过 xray 生成 x25519 密钥，使用 openssl 生成替代密钥（兼容性视版本而定）"
        if command -v openssl >/dev/null 2>&1; then
            # 生成私钥并导出为 hex（这不是 xray 原生输出，但可以作为占位）
            PRIVATE_KEY=$(openssl rand -hex 32)
            PUBLIC_KEY=$(openssl rand -hex 32)
        else
            red "[!] 无法生成密钥，请安装 xray 或 openssl"
            exit 1
        fi
    fi

    # 生成短 ID (8位十六进制)
    SHORT_ID=$(openssl rand -hex 4)

    # 生成更安全的端口 (443 或高端口)
    if ss -tlnp 2>/dev/null | grep -q ":443 "; then
        LISTEN_PORT=$(shuf -i 10000-65000 -n 1)
        while ss -tlnp 2>/dev/null | grep -q ":$LISTEN_PORT "; do
            LISTEN_PORT=$(shuf -i 10000-65000 -n 1)
        done
    else
        LISTEN_PORT=443
    fi

    yellow "[*] 用户 UUID: $USER_UUID"
    yellow "[*] 监听端口: $LISTEN_PORT"
    yellow "[*] Short ID: $SHORT_ID"

    mkdir -p "$XRAY_DIR"
    cat > "$XRAY_DIR/keys.txt" <<EOF
Private Key: $PRIVATE_KEY
Public Key: $PUBLIC_KEY
UUID: $USER_UUID
Short ID: $SHORT_ID
Listen Port: $LISTEN_PORT
Reality Target: $REALITY_DEST:$REALITY_PORT
Generated: $(date -u)
EOF
    chmod 600 "$XRAY_DIR/keys.txt"
}

# 配置 Xray 服务器
configure_xray_server() {
    yellow "[*] 配置 Xray 服务器..."

    mkdir -p "$XRAY_DIR" /var/log/xray

    cat > "$XRAY_DIR/config.json" <<EOF
{
    "log": {
        "access": "$LOG_FILE",
        "error": "$ERROR_LOG",
        "loglevel": "warning"
    },
    "inbounds": [
        {
            "port": $LISTEN_PORT,
            "protocol": "vless",
            "settings": {
                "clients": [
                    {
                        "id": "$USER_UUID",
                        "flow": ""
                    }
                ],
                "decryption": "none"
            },
            "streamSettings": {
                "network": "tcp",
                "security": "reality",
                "realitySettings": {
                    "dest": "$REALITY_DEST:$REALITY_PORT",
                    "serverNames": [
                        "$REALITY_DEST"
                    ],
                    "privateKey": "$PRIVATE_KEY",
                    "shortIds": [
                        "$SHORT_ID"
                    ]
                }
            },
            "sniffing": {
                "enabled": true,
                "destOverride": ["http", "tls"]
            }
        }
    ],
    "outbounds": [
        {
            "protocol": "freedom",
            "settings": {},
            "tag": "direct"
        },
        {
            "protocol": "blackhole",
            "settings": {},
            "tag": "blocked"
        }
    ],
    "routing": {
        "domainStrategy": "AsIs",
        "rules": [
            {
                "type": "field",
                "ip": [
                    "geoip:private"
                ],
                "outboundTag": "blocked"
            },
            {
                "type": "field",
                "domain": [
                    "geosite:category-ads-all"
                ],
                "outboundTag": "blocked"
            }
        ]
    },
    "policy": {
        "levels": {
            "0": {
                "handshake": 4,
                "connIdle": 300,
                "uplinkOnly": 5,
                "downlinkOnly": 30,
                "statsUserUplink": false,
                "statsUserDownlink": false,
                "bufferSize": 10240
            }
        },
        "system": {
            "statsInboundUplink": false,
            "statsInboundDownlink": false
        }
    }
}
EOF

    chmod 644 "$XRAY_DIR/config.json"

    # 验证配置（xray -test 的选项在不同版本可能不同）
    if command -v /usr/local/bin/xray >/dev/null 2>&1; then
        /usr/local/bin/xray -test -config="$XRAY_DIR/config.json" 2>/dev/null || true
    fi
    green "[*] Xray 配置已写入: $XRAY_DIR/config.json"
}

# 配置 Nginx 伪装 (可选)
configure_nginx_camouflage() {
    if [[ "$USE_REAL_DOMAIN" == "true" ]]; then
        yellow "[*] 配置 Nginx 伪装并申请证书..."

        # 申请 SSL 证书（非交互）
        certbot --nginx -d "$DOMAIN" --non-interactive --agree-tos --email "admin@$DOMAIN" --redirect || true

        # 配置 Nginx 反向代理
        cat > "/etc/nginx/sites-available/$DOMAIN" <<EOF
server {
    listen 80;
    server_name $DOMAIN;
    return 301 https://\$server_name\$request_uri;
}

server {
    listen 443 ssl http2;
    server_name $DOMAIN;

    ssl_certificate /etc/letsencrypt/live/$DOMAIN/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/$DOMAIN/privkey.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;

    # 伪装成正常网站
    location / {
        proxy_pass https://$REALITY_DEST;
        proxy_set_header Host $REALITY_DEST;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_ssl_server_name on;
        proxy_ssl_verify off;
    }

    # 隐藏服务器信息
    server_tokens off;
}
EOF

        ln -sf "/etc/nginx/sites-available/$DOMAIN" "/etc/nginx/sites-enabled/$DOMAIN"
        nginx -t && systemctl reload nginx || true
    fi
}

# 创建 systemd 服务
create_systemd_service() {
    yellow "[*] 创建 Xray 系统服务..."

    cat > /etc/systemd/system/xray.service <<EOF
[Unit]
Description=Xray Service
Documentation=https://github.com/xtls
After=network.target nss-lookup.target

[Service]
User=root
ExecStart=/usr/local/bin/xray run -config $XRAY_DIR/config.json
Restart=on-failure
RestartPreventExitStatus=23
LimitNPROC=10000
LimitNOFILE=1000000

# 安全设置
NoNewPrivileges=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=/var/log/xray
PrivateTmp=true
ProtectControlGroups=true
ProtectKernelTunables=true
ProtectKernelModules=true
MemoryDenyWriteExecute=true
RestrictRealtime=true
RestrictSUIDSGID=true

[Install]
WantedBy=multi-user.target
EOF

    systemctl daemon-reload || true
    systemctl enable xray || true
    systemctl start xray || true

    if systemctl is-active --quiet xray; then
        green "[*] Xray 服务启动成功"
    else
        red "[!] Xray 服务未能成功启动，查看 journalctl -u xray 获取详情"
    fi
}

# 配置防火墙
configure_firewall() {
    yellow "[*] 配置防火墙..."

    # UFW 配置
    if command -v ufw &> /dev/null; then
        ufw --force reset || true
        ufw default deny incoming || true
        ufw default allow outgoing || true
        ufw allow ssh || true
        ufw allow $LISTEN_PORT comment 'VLESS Reality' || true

        if [[ "$USE_REAL_DOMAIN" == "true" ]]; then
            ufw allow 80 comment 'HTTP' || true
            ufw allow 443 comment 'HTTPS' || true
        fi

        ufw --force enable || true
    fi

    # iptables 备用规则
    iptables -I INPUT -p tcp --dport $LISTEN_PORT -j ACCEPT || true
    iptables -I INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT || true

    # 保存规则（如果系统提供）
    if command -v iptables-save &> /dev/null; then
        mkdir -p /etc/iptables || true
        iptables-save > /etc/iptables/rules.v4 2>/dev/null || true
    fi
}

# 生成客户端配置
generate_client_configs() {
    yellow "[*] 生成客户端配置..."

    mkdir -p "$CLIENT_DIR"

    cat > "$CLIENT_DIR/client.json" <<EOF
{
    "log": {
        "loglevel": "warning"
    },
    "inbounds": [
        {
            "port": 1080,
            "listen": "127.0.0.1",
            "protocol": "socks",
            "settings": {
                "udp": true
            }
        },
        {
            "port": 1081,
            "listen": "127.0.0.1",
            "protocol": "http"
        }
    ],
    "outbounds": [
        {
            "protocol": "vless",
            "settings": {
                "vnext": [
                    {
                        "address": "$SERVER_IP",
                        "port": $LISTEN_PORT,
                        "users": [
                            {
                                "id": "$USER_UUID",
                                "encryption": "none"
                            }
                        ]
                    }
                ]
            },
            "streamSettings": {
                "network": "tcp",
                "security": "reality",
                "realitySettings": {
                    "serverName": "$REALITY_DEST",
                    "fingerprint": "chrome",
                    "publicKey": "$PUBLIC_KEY",
                    "shortId": "$SHORT_ID"
                }
            },
            "tag": "proxy"
        },
        {
            "protocol": "freedom",
            "tag": "direct"
        }
    ],
    "routing": {
        "domainStrategy": "IPIfNonMatch",
        "rules": [
            {
                "type": "field",
                "domain": ["geosite:cn"],
                "outboundTag": "direct"
            },
            {
                "type": "field",
                "ip": ["geoip:cn", "geoip:private"],
                "outboundTag": "direct"
            }
        ]
    }
}
EOF

    # 生成分享链接
    VLESS_LINK="vless://$USER_UUID@$SERVER_IP:$LISTEN_PORT?encryption=none&flow=&security=reality&sni=$REALITY_DEST&fp=chrome&pbk=$PUBLIC_KEY&sid=$SHORT_ID&type=tcp&headerType=none#VLESS-Reality-$(date +%s)"

    echo "$VLESS_LINK" > "$CLIENT_DIR/share-link.txt"

    cat > "$CLIENT_DIR/client-info.txt" <<EOF
VLESS Reality 客户端信息
========================

连接信息:
- 服务器地址: $SERVER_IP
- 端口: $LISTEN_PORT
- UUID: $USER_UUID
- 加密: none
- 传输协议: tcp
- 安全层: reality
- SNI: $REALITY_DEST
- 指纹: chrome
- 公钥: $PUBLIC_KEY
- Short ID: $SHORT_ID

分享链接:
$VLESS_LINK

客户端配置文件: $CLIENT_DIR/client.json

支持的客户端:
- v2rayN (Windows)
- v2rayNG (Android)
- Qv2ray (跨平台)
- Clash Meta (支持 Reality)
- sing-box (推荐)

本地代理端口:
- SOCKS5: 127.0.0.1:1080
- HTTP: 127.0.0.1:1081

生成时间: $(date -u)
EOF

    chmod 600 "$CLIENT_DIR"/* || true
    green "[*] 客户端配置已生成: $CLIENT_DIR/"
}

# 系统优化
optimize_system() {
    yellow "[*] 优化系统性能..."

    # 网络参数优化
    cat >> /etc/sysctl.conf <<EOF

# VLESS Reality 网络优化
net.core.rmem_max = 134217728
net.core.wmem_max = 134217728
net.core.netdev_max_backlog = 4096
net.ipv4.tcp_rmem = 4096 65536 134217728
net.ipv4.tcp_wmem = 4096 65536 134217728
net.ipv4.tcp_congestion_control = bbr
net.core.default_qdisc = fq
net.ipv4.tcp_fastopen = 3
net.ipv4.tcp_slow_start_after_idle = 0
net.ipv4.tcp_keepalive_time = 600
net.ipv4.tcp_keepalive_intvl = 60
net.ipv4.tcp_keepalive_probes = 10
net.ipv4.ip_forward = 1
fs.file-max = 1048576
EOF

    sysctl -p || true

    # 设置文件描述符限制
    cat >> /etc/security/limits.conf <<EOF
* soft nofile 1048576
* hard nofile 1048576
root soft nofile 1048576
root hard nofile 1048576
EOF

    # 优化 systemd 限制
    mkdir -p /etc/systemd/system.conf.d
    cat > /etc/systemd/system.conf.d/limits.conf <<EOF
[Manager]
DefaultLimitNOFILE=1048576
EOF

    systemctl daemon-reload || true
}

# 创建管理脚本
create_management_tools() {
    yellow "[*] 创建管理工具..."

    cat > /usr/local/bin/vless-mgr <<'EOF'
#!/bin/bash

XRAY_DIR="/usr/local/etc/xray"
CLIENT_DIR="/root/vless-clients"
LOG_FILE="/var/log/xray/access.log"
ERROR_LOG="/var/log/xray/error.log"

show_status() {
    echo "=== VLESS Reality 服务状态 ==="
    systemctl status xray --no-pager -l || true
    echo ""
    echo "=== 连接统计 ==="
    if [[ -f "$LOG_FILE" ]]; then
        echo "今日连接数: $(grep "$(date +%Y/%m/%d)" "$LOG_FILE" | wc -l)"
        echo "活跃IP数: $(tail -1000 "$LOG_FILE" | awk '{print $3}' | sort -u | wc -l)"
    fi
    echo ""
    echo "=== 系统资源 ==="
    echo "CPU使用率: $(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | awk -F'%' '{print $1}')"
    echo "内存使用: $(free -h | grep Mem | awk '{print $3"/"$2}')"
    echo "磁盘使用: $(df -h / | tail -1 | awk '{print $5}')"
}

show_config() {
    echo "=== 配置信息 ==="
    if [[ -f "$CLIENT_DIR/client-info.txt" ]]; then
        cat "$CLIENT_DIR/client-info.txt"
    else
        echo "配置文件不存在"
    fi
}

show_qr() {
    echo "=== 二维码 ==="
    if [[ -f "$CLIENT_DIR/share-link.txt" ]]; then
        qrencode -t ANSIUTF8 < "$CLIENT_DIR/share-link.txt"
    else
        echo "分享链接不存在"
    fi
}

view_logs() {
    case "$1" in
        access|"")
            echo "=== 访问日志 (最近50行) ==="
            tail -50 "$LOG_FILE" 2>/dev/null || echo "日志文件不存在"
            ;;
        error)
            echo "=== 错误日志 (最近50行) ==="
            tail -50 "$ERROR_LOG" 2>/dev/null || echo "日志文件不存在"
            ;;
        live)
            echo "=== 实时日志 (Ctrl+C 退出) ==="
            tail -f "$LOG_FILE" "$ERROR_LOG"
            ;;
    esac
}

restart_service() {
    echo "重启 Xray 服务..."
    systemctl restart xray
    if systemctl is-active --quiet xray; then
        echo "✅ 服务重启成功"
    else
        echo "❌ 服务重启失败"
        systemctl status xray --no-pager -l || true
    fi
}

case "$1" in
    status|st)
        show_status
        ;;
    config|cfg)
        show_config
        ;;
    qr)
        show_qr
        ;;
    logs|log)
        view_logs "$2"
        ;;
    restart|rs)
        restart_service
        ;;
    *)
        echo "VLESS Reality 管理工具"
        echo ""
        echo "用法: vless-mgr {status|config|qr|logs|restart}"
        ;;
esac
EOF

    chmod +x /usr/local/bin/vless-mgr || true
    green "[*] 管理工具已创建: /usr/local/bin/vless-mgr"
}

# 主流程
main() {
    detect_system
    install_dependencies
    get_server_ip
    select_camouflage_domain
    select_reality_target
    if ! install_xray; then
        red "[!] Xray 安装失败，退出"
        exit 1
    fi
    generate_keys
    configure_xray_server
    configure_nginx_camouflage
    create_systemd_service
    configure_firewall
    generate_client_configs
    optimize_system
    create_management_tools

    green "[*] 安装完成！"
    echo "客户端配置位置: $CLIENT_DIR"
    echo "管理命令: vless-mgr"
    echo "检查服务状态: systemctl status xray"
}

# 如果脚本作为命令直接运行，则执行主流程
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi