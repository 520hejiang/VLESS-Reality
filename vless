#!/bin/bash

# ============================================
# Xray Reality 一键安装脚本 - 完整修复版
# 修复：IP转发、NAT规则、DNS配置
# ============================================

set -e

# 颜色输出函数
red() { echo -e "\033[31m$1\033[0m"; }
green() { echo -e "\033[32m$1\033[0m"; }
yellow() { echo -e "\033[33m$1\033[0m"; }
blue() { echo -e "\033[34m$1\033[0m"; }

# 配置目录
XRAY_DIR="/usr/local/etc/xray"
CLIENT_DIR="/root/xray-client"
LOG_DIR="/var/log/xray"
BACKUP_DIR="/root/xray-backup"

# Reality 配置 - 防封锁优化
REALITY_DEST="www.microsoft.com"  # 使用大型可信站点
REALITY_PORT="443"
REALITY_SNI="www.microsoft.com"   # SNI与目标站点一致

# 防封锁配置
ENABLE_CAMOUFLAGE=true           # 启用流量伪装
ENABLE_RANDOM_PORT=false         # 是否随机端口（建议443）
ENABLE_TRAFFIC_OBFUSCATION=true  # 启用流量混淆

# 全局变量
LISTEN_PORT=""
USER_UUID=""
PRIVATE_KEY=""
PUBLIC_KEY=""
SHORT_ID=""
NET_INTERFACE=""

# ============================================
# 检查系统环境
# ============================================
check_system() {
    blue "================================================"
    blue "  Xray Reality 一键安装脚本 - 完整修复版"
    blue "================================================"
    echo

    # 检查root权限
    if [[ $EUID -ne 0 ]]; then
        red "[!] 错误：请使用 root 权限运行此脚本"
        red "    使用命令: sudo bash $0"
        exit 1
    fi

    # 检查系统类型
    if [[ -f /etc/os-release ]]; then
        . /etc/os-release
        OS=$ID
        VERSION=$VERSION_ID
    else
        red "[!] 无法识别系统类型"
        exit 1
    fi

    green "[✓] 系统检查通过: $OS $VERSION"

    # 检查网络
    if ! ping -c 1 8.8.8.8 &>/dev/null; then
        red "[!] 网络连接异常，请检查网络设置"
        exit 1
    fi
    green "[✓] 网络连接正常"
}

# ============================================
# 1. 安装系统依赖
# ============================================
install_dependencies() {
    green "\n[1/8] 安装系统依赖..."

    if [[ "$OS" == "ubuntu" ]] || [[ "$OS" == "debian" ]]; then
        apt-get update -y
        apt-get install -y curl wget unzip qrencode iptables iptables-persistent \
            net-tools sudo openssl ca-certificates
    elif [[ "$OS" == "centos" ]] || [[ "$OS" == "rhel" ]]; then
        yum install -y curl wget unzip qrencode iptables iptables-services \
            net-tools sudo openssl ca-certificates
    else
        red "[!] 不支持的系统类型: $OS"
        exit 1
    fi

    green "[✓] 依赖安装完成"
}

# ============================================
# 2. 配置系统网络参数（关键！）
# ============================================
configure_system() {
    green "\n[2/8] 配置系统网络参数..."

    # 备份原有配置
    if [[ -f /etc/sysctl.conf ]]; then
        cp /etc/sysctl.conf /etc/sysctl.conf.bak.$(date +%Y%m%d_%H%M%S)
    fi

    # 创建 Xray 专用配置文件
    cat > /etc/sysctl.d/99-xray.conf <<'EOF'
# IPv4 转发 (必须!)
net.ipv4.ip_forward = 1

# IPv6 转发
net.ipv6.conf.all.forwarding = 1

# 允许本地路由
net.ipv4.conf.all.route_localnet = 1

# TCP 优化
net.core.default_qdisc = fq
net.ipv4.tcp_congestion_control = bbr

# 连接追踪优化
net.netfilter.nf_conntrack_max = 1000000
net.netfilter.nf_conntrack_tcp_timeout_established = 7200

# 网络缓冲区优化
net.core.rmem_max = 134217728
net.core.wmem_max = 134217728
net.ipv4.tcp_rmem = 4096 87380 67108864
net.ipv4.tcp_wmem = 4096 65536 67108864
EOF

    # 应用配置
    sysctl -p /etc/sysctl.d/99-xray.conf >/dev/null 2>&1

    # 验证 IP 转发是否启用
    if [[ $(cat /proc/sys/net/ipv4/ip_forward) != "1" ]]; then
        red "[!] IP 转发启用失败，尝试手动启用..."
        echo 1 > /proc/sys/net/ipv4/ip_forward
        
        if [[ $(cat /proc/sys/net/ipv4/ip_forward) != "1" ]]; then
            red "[!] IP 转发无法启用，脚本终止"
            exit 1
        fi
    fi

    green "[✓] 系统参数配置完成"
    yellow "    - IP转发: $(cat /proc/sys/net/ipv4/ip_forward)"
    yellow "    - BBR: $(sysctl net.ipv4.tcp_congestion_control | awk '{print $3}')"
}

# ============================================
# 3. 安装 Xray-core
# ============================================
install_xray() {
    green "\n[3/8] 安装 Xray-core..."

    # 检查是否已安装
    if [[ -f /usr/local/bin/xray ]]; then
        yellow "[*] 检测到已安装 Xray，正在更新..."
        bash -c "$(curl -L https://github.com/XTLS/Xray-install/raw/main/install-release.sh)" @ install
    else
        yellow "[*] 开始安装 Xray..."
        bash -c "$(curl -L https://github.com/XTLS/Xray-install/raw/main/install-release.sh)" @ install
    fi

    # 验证安装
    if [[ ! -f /usr/local/bin/xray ]]; then
        red "[!] Xray 安装失败"
        exit 1
    fi

    XRAY_VERSION=$(xray version 2>/dev/null | head -1)
    green "[✓] Xray 安装成功: $XRAY_VERSION"

    # 创建必要目录
    mkdir -p "$XRAY_DIR" "$CLIENT_DIR" "$LOG_DIR" "$BACKUP_DIR"
    chmod 755 "$XRAY_DIR" "$LOG_DIR"
    chmod 700 "$CLIENT_DIR" "$BACKUP_DIR"
}

# ============================================
# 4. 生成 Reality 密钥
# ============================================
generate_keys() {
    green "\n[4/8] 生成 Reality 密钥..."

    # 生成 UUID
    USER_UUID=$(cat /proc/sys/kernel/random/uuid)
    yellow "[*] UUID: $USER_UUID"

    # 检测 xray 可执行文件
    XRAY_BIN=""
    for path in /usr/local/bin/xray /usr/bin/xray /root/xray /opt/xray/xray; do
        if [[ -x "$path" ]]; then
            XRAY_BIN="$path"
            break
        fi
    done

    if [[ -z "$XRAY_BIN" ]]; then
        red "[!] 未检测到 xray 可执行文件"
        red "    请检查 Xray 是否正确安装"
        exit 1
    fi

    yellow "[*] 使用 Xray: $XRAY_BIN"

    # 生成密钥对
    local temp_key_file="/tmp/xray_keys_$$.txt"
    
    if ! "$XRAY_BIN" x25519 > "$temp_key_file" 2>&1; then
        red "[!] 密钥生成失败"
        cat "$temp_key_file"
        rm -f "$temp_key_file"
        exit 1
    fi

    # 提取密钥 (兼容多种输出格式)
    PRIVATE_KEY=$(awk '/[Pp]rivate/{print $NF}' "$temp_key_file" | tr -d '\r\n' | head -1)
    PUBLIC_KEY=$(awk '/[Pp]ublic/{print $NF}' "$temp_key_file" | tr -d '\r\n' | head -1)

    # 如果提取失败，使用正则表达式
    if [[ -z "$PRIVATE_KEY" || -z "$PUBLIC_KEY" ]]; then
        PRIVATE_KEY=$(grep -ioE '[A-Za-z0-9_-]{40,}' "$temp_key_file" | head -1)
        PUBLIC_KEY=$(grep -ioE '[A-Za-z0-9_-]{40,}' "$temp_key_file" | tail -1)
    fi

    rm -f "$temp_key_file"

    # 验证密钥
    if [[ -z "$PRIVATE_KEY" ]] || [[ ${#PRIVATE_KEY} -lt 40 ]]; then
        red "[!] Private Key 生成失败或格式错误"
        red "    Private Key: '$PRIVATE_KEY'"
        exit 1
    fi

    if [[ -z "$PUBLIC_KEY" ]] || [[ ${#PUBLIC_KEY} -lt 40 ]]; then
        red "[!] Public Key 生成失败或格式错误"
        red "    Public Key: '$PUBLIC_KEY'"
        exit 1
    fi

    # 生成 Short ID
    SHORT_ID=$(openssl rand -hex 8)

    # 端口分配 - 防封锁策略
    if [[ "$ENABLE_RANDOM_PORT" == "true" ]]; then
        # 随机高位端口（更隐蔽但可能被限制）
        LISTEN_PORT=$(shuf -i 20000-50000 -n 1)
        yellow "[*] 使用随机端口: $LISTEN_PORT（增强隐蔽性）"
    else
        # 优先使用443（伪装成HTTPS流量）
        if ss -tlnp 2>/dev/null | grep -q ":443 " || netstat -tlnp 2>/dev/null | grep -q ":443 "; then
            # 443被占用，使用其他常见端口
            for port in 8443 2053 2083 2087 2096; do
                if ! ss -tlnp 2>/dev/null | grep -q ":$port "; then
                    LISTEN_PORT=$port
                    break
                fi
            done
            if [[ -z "$LISTEN_PORT" ]]; then
                LISTEN_PORT=$(shuf -i 10000-65000 -n 1)
            fi
            yellow "[!] 443端口被占用，使用备用端口: $LISTEN_PORT"
        else
            LISTEN_PORT=443
            green "[*] 使用最佳端口: 443（伪装HTTPS流量）"
        fi
    fi

    # 保存密钥信息
    cat > "$XRAY_DIR/keys.txt" <<EOF
================================================
Xray Reality 密钥信息
================================================
Private Key: $PRIVATE_KEY
Public Key: $PUBLIC_KEY
UUID: $USER_UUID
Short ID: $SHORT_ID
Listen Port: $LISTEN_PORT
Reality Target: $REALITY_DEST:$REALITY_PORT
Reality SNI: $REALITY_SNI
Generated: $(date '+%Y-%m-%d %H:%M:%S')
================================================
EOF

    chmod 600 "$XRAY_DIR/keys.txt"

    green "[✓] 密钥生成成功"
    yellow "    Private Key: ${PRIVATE_KEY:0:20}...${PRIVATE_KEY: -10}"
    yellow "    Public Key: ${PUBLIC_KEY:0:20}...${PUBLIC_KEY: -10}"
    yellow "    Short ID: $SHORT_ID"
}

# ============================================
# 5. 配置防火墙规则（关键！）
# ============================================
configure_firewall() {
    green "\n[5/8] 配置防火墙规则..."

    # 检测网卡
    NET_INTERFACE=$(ip -4 route ls | grep default | grep -Po '(?<=dev )(\S+)' | head -1)
    if [[ -z "$NET_INTERFACE" ]]; then
        NET_INTERFACE=$(ip -4 addr | grep -oP '(?<=^\d: )\w+' | grep -v lo | head -1)
    fi
    if [[ -z "$NET_INTERFACE" ]]; then
        NET_INTERFACE="eth0"
    fi

    yellow "[*] 使用网卡: $NET_INTERFACE"

    # 清理旧规则 (谨慎操作)
    iptables -t nat -F 2>/dev/null || true
    iptables -t mangle -F 2>/dev/null || true
    iptables -F 2>/dev/null || true
    iptables -X 2>/dev/null || true

    # 设置默认策略
    iptables -P INPUT ACCEPT
    iptables -P FORWARD ACCEPT
    iptables -P OUTPUT ACCEPT

    # 允许本地回环
    iptables -A INPUT -i lo -j ACCEPT
    iptables -A OUTPUT -o lo -j ACCEPT

    # 允许已建立的连接
    iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
    iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

    # 允许 SSH (防止锁死)
    iptables -A INPUT -p tcp --dport 22 -j ACCEPT

    # 允许 Xray 端口
    iptables -A INPUT -p tcp --dport "$LISTEN_PORT" -j ACCEPT

    # 防DPI检测 - 允许常见端口出站
    iptables -A OUTPUT -p tcp --dport 80 -j ACCEPT
    iptables -A OUTPUT -p tcp --dport 443 -j ACCEPT
    iptables -A OUTPUT -p tcp --dport 53 -j ACCEPT
    iptables -A OUTPUT -p udp --dport 53 -j ACCEPT

    # 限制连接速率（防主动探测）
    iptables -A INPUT -p tcp --dport "$LISTEN_PORT" -m state --state NEW -m recent --set
    iptables -A INPUT -p tcp --dport "$LISTEN_PORT" -m state --state NEW -m recent --update --seconds 60 --hitcount 10 -j DROP

    # NAT 转发规则 (核心！)
    iptables -t nat -A POSTROUTING -o "$NET_INTERFACE" -j MASQUERADE

    # FORWARD 规则
    iptables -A FORWARD -i "$NET_INTERFACE" -o "$NET_INTERFACE" -m state --state RELATED,ESTABLISHED -j ACCEPT
    iptables -A FORWARD -i "$NET_INTERFACE" -o "$NET_INTERFACE" -j ACCEPT

    # 保存规则
    if command -v netfilter-persistent &>/dev/null; then
        netfilter-persistent save
        green "[✓] 规则已保存 (netfilter-persistent)"
    elif command -v iptables-save &>/dev/null; then
        mkdir -p /etc/iptables
        iptables-save > /etc/iptables/rules.v4
        green "[✓] 规则已保存 (/etc/iptables/rules.v4)"
    fi

    green "[✓] 防火墙规则配置完成"
}

# ============================================
# 6. 生成服务端配置文件
# ============================================
generate_server_config() {
    green "\n[6/8] 生成服务端配置..."

    # 备份旧配置
    if [[ -f "$XRAY_DIR/config.json" ]]; then
        cp "$XRAY_DIR/config.json" "$BACKUP_DIR/config.json.bak.$(date +%Y%m%d_%H%M%S)"
    fi

    # 生成新配置
    cat > "$XRAY_DIR/config.json" <<EOF
{
  "log": {
    "loglevel": "warning",
    "access": "$LOG_DIR/access.log",
    "error": "$LOG_DIR/error.log"
  },
  "inbounds": [
    {
      "port": $LISTEN_PORT,
      "protocol": "vless",
      "settings": {
        "clients": [
          {
            "id": "$USER_UUID",
            "flow": "xtls-rprx-vision"
          }
        ],
        "decryption": "none"
      },
      "streamSettings": {
        "network": "tcp",
        "security": "reality",
        "realitySettings": {
          "show": false,
          "dest": "$REALITY_DEST:$REALITY_PORT",
          "xver": 0,
          "serverNames": [
            "$REALITY_SNI",
            "www.microsoft.com",
            "www.apple.com",
            "www.cloudflare.com"
          ],
          "privateKey": "$PRIVATE_KEY",
          "shortIds": [
            "$SHORT_ID",
            ""
          ],
          "minClientVer": "",
          "maxClientVer": "",
          "maxTimeDiff": 0
        }
      },
      "sniffing": {
        "enabled": true,
        "destOverride": [
          "http",
          "tls",
          "quic",
          "fakedns"
        ],
        "metadataOnly": false
      }
    }
  ],
  "outbounds": [
    {
      "protocol": "freedom",
      "tag": "direct",
      "settings": {
        "domainStrategy": "UseIPv4"
      }
    },
    {
      "protocol": "blackhole",
      "tag": "block"
    }
  ],
  "routing": {
    "domainStrategy": "IPIfNonMatch",
    "rules": [
      {
        "type": "field",
        "protocol": [
          "bittorrent"
        ],
        "outboundTag": "block"
      },
      {
        "type": "field",
        "ip": [
          "geoip:private"
        ],
        "outboundTag": "block"
      },
      {
        "type": "field",
        "domain": [
          "geosite:category-ads-all"
        ],
        "outboundTag": "block"
      }
    ]
  },
  "dns": {
    "servers": [
      {
        "address": "https://dns.google/dns-query",
        "domains": [
          "geosite:geolocation-!cn"
        ]
      },
      {
        "address": "https://cloudflare-dns.com/dns-query",
        "domains": [
          "geosite:geolocation-!cn"
        ]
      },
      "8.8.8.8",
      "1.1.1.1"
    ],
    "queryStrategy": "UseIPv4",
    "disableCache": false,
    "disableFallback": false
  },
  "policy": {
    "levels": {
      "0": {
        "handshake": 4,
        "connIdle": 300,
        "uplinkOnly": 2,
        "downlinkOnly": 5
      }
    }
  }
}
EOF

    chmod 644 "$XRAY_DIR/config.json"

    # 验证配置
    if ! xray -test -config="$XRAY_DIR/config.json" >/dev/null 2>&1; then
        red "[!] 配置文件验证失败"
        xray -test -config="$XRAY_DIR/config.json"
        exit 1
    fi

    green "[✓] 服务端配置生成完成"
}

# ============================================
# 7. 启动 Xray 服务
# ============================================
start_xray_service() {
    green "\n[7/8] 启动 Xray 服务..."

    # 停止旧服务
    systemctl stop xray 2>/dev/null || true

    # 重载守护进程
    systemctl daemon-reload

    # 启用开机自启
    systemctl enable xray

    # 启动服务
    systemctl start xray

    # 等待服务启动
    sleep 3

    # 检查服务状态
    if systemctl is-active --quiet xray; then
        green "[✓] Xray 服务启动成功"
    else
        red "[!] Xray 服务启动失败，查看日志："
        journalctl -u xray -n 30 --no-pager
        exit 1
    fi

    # 检查端口监听
    sleep 2
    if ss -tlnp | grep -q ":$LISTEN_PORT "; then
        green "[✓] 端口 $LISTEN_PORT 正在监听"
    else
        yellow "[!] 警告：端口 $LISTEN_PORT 未检测到监听"
    fi
}

# ============================================
# 8. 生成客户端配置
# ============================================
generate_client_config() {
    green "\n[8/8] 生成客户端配置..."

    # 获取服务器IP
    SERVER_IP=$(curl -s https://api.ipify.org || curl -s https://ifconfig.me || curl -s https://icanhazip.com)
    
    if [[ -z "$SERVER_IP" ]]; then
        yellow "[!] 无法自动获取服务器IP，请手动输入："
        read -p "服务器IP: " SERVER_IP
    fi

    yellow "[*] 服务器IP: $SERVER_IP"

    # 生成 VLESS 链接 - 使用 Chrome 浏览器指纹
    VLESS_LINK="vless://${USER_UUID}@${SERVER_IP}:${LISTEN_PORT}?encryption=none&flow=xtls-rprx-vision&security=reality&sni=${REALITY_SNI}&fp=chrome&pbk=${PUBLIC_KEY}&sid=${SHORT_ID}&type=tcp&headerType=none#Xray-Reality-${SERVER_IP}"

    # 保存客户端配置
    cat > "$CLIENT_DIR/client-config.txt" <<EOF
================================================
Xray Reality 客户端配置
================================================

连接信息:
服务器地址: $SERVER_IP
端口: $LISTEN_PORT
UUID: $USER_UUID
Public Key: $PUBLIC_KEY
Short ID: $SHORT_ID
SNI: $REALITY_SNI
Flow: xtls-rprx-vision
安全性: reality
传输协议: tcp
指纹: chrome

================================================
VLESS 分享链接:
================================================
$VLESS_LINK

================================================
客户端推荐:
================================================
- Windows: v2rayN (https://github.com/2dust/v2rayN/releases)
- Android: v2rayNG (https://github.com/2dust/v2rayNG/releases)
- iOS: Shadowrocket / Stash
- macOS: V2rayU / Qv2ray

使用方法:
1. 复制上方 VLESS 链接
2. 在客户端中选择 "从剪贴板导入"
3. 连接即可使用

================================================
防封锁建议:
================================================
✓ Reality 协议：无特征流量，GFW无法检测
✓ 使用 443 端口：伪装成正常 HTTPS 流量
✓ 目标站点：${REALITY_DEST}（大型可信网站）
✓ Chrome 指纹：模拟真实浏览器行为
✓ 连接速率限制：防止主动探测攻击

安全提示:
• 不要分享配置给不信任的人
• 定期更换 UUID 和 ShortID
• 避免在敏感时期大流量使用
• 建议启用客户端的自动切换节点功能

================================================
生成时间: $(date '+%Y-%m-%d %H:%M:%S')
================================================
EOF

    chmod 600 "$CLIENT_DIR/client-config.txt"

    # 生成二维码
    if command -v qrencode &>/dev/null; then
        echo "$VLESS_LINK" | qrencode -o "$CLIENT_DIR/qrcode.png"
        green "[✓] 二维码已保存: $CLIENT_DIR/qrcode.png"
    fi

    green "[✓] 客户端配置已保存: $CLIENT_DIR/client-config.txt"
}

# ============================================
# 显示安装结果
# ============================================
show_result() {
    clear
    blue "========================================================"
    green "           Xray Reality 安装完成！"
    blue "========================================================"
    echo
    green "✓ 服务状态: $(systemctl is-active xray)"
    green "✓ 监听端口: $LISTEN_PORT"
    green "✓ 服务器IP: $(curl -s https://api.ipify.org)"
    green "✓ Reality目标: $REALITY_DEST"
    echo
    yellow "防封锁特性:"
    echo "  ✓ Reality 协议 - 无特征流量，GFW无法识别"
    echo "  ✓ TLS指纹伪装 - 模拟 Chrome 浏览器"
    echo "  ✓ 端口策略 - 优先使用443端口（HTTPS）"
    echo "  ✓ 连接限速 - 防止主动探测攻击"
    echo "  ✓ 多域名SNI - 增强伪装效果"
    echo "  ✓ Vision协议 - 抗封锁能力最强"
    echo
    yellow "配置文件位置:"
    echo "  • 服务端配置: $XRAY_DIR/config.json"
    echo "  • 客户端配置: $CLIENT_DIR/client-config.txt"
    echo "  • 密钥文件: $XRAY_DIR/keys.txt"
    echo "  • 二维码: $CLIENT_DIR/qrcode.png"
    echo
    yellow "常用管理命令:"
    echo "  • 查看状态: systemctl status xray"
    echo "  • 启动服务: systemctl start xray"
    echo "  • 停止服务: systemctl stop xray"
    echo "  • 重启服务: systemctl restart xray"
    echo "  • 查看日志: journalctl -u xray -f"
    echo "  • 测试配置: xray -test -config $XRAY_DIR/config.json"
    echo "  • 防火墙规则: iptables -L -n -v"
    echo
    yellow "客户端连接信息:"
    echo "────────────────────────────────────────────────────────"
    cat "$CLIENT_DIR/client-config.txt" | grep -A 1 "VLESS 分享链接:"
    echo "────────────────────────────────────────────────────────"
    echo
    red "⚠️  安全建议:"
    echo "  • 请妥善保管配置信息，不要泄露给他人"
    echo "  • 定期更新 Xray 版本: bash <(curl -L https://github.com/XTLS/Xray-install/raw/main/install-release.sh)"
    echo "  • 建议每月更换一次 UUID 和密钥"
    echo "  • 避免在敏感时期进行大流量传输"
    echo "  • 推荐使用 CDN 中转进一步增强抗封锁能力"
    echo
    blue "========================================================"
    green "提示: Reality 协议理论上无法被 GFW 识别和封锁"
    blue "========================================================"
    echo
}

# ============================================
# 主函数
# ============================================
main() {
    check_system
    install_dependencies
    configure_system
    install_xray
    generate_keys
    configure_firewall
    generate_server_config
    start_xray_service
    generate_client_config
    show_result
}

# 执行主函数
main